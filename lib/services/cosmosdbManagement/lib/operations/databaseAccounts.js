/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

const msRest = require('ms-rest');
const msRestAzure = require('ms-rest-azure');
const WebResource = msRest.WebResource;

/**
 * Retrieves the properties of an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DatabaseAccount} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _get(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DatabaseAccount']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Patches the properties of an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} updateParameters The tags parameter to patch for the current
 * database account.
 *
 * @param {object} [updateParameters.tags]
 *
 * @param {array} [updateParameters.capabilities] List of Cosmos DB
 * capabilities for the account
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DatabaseAccount} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _patch(resourceGroupName, accountName, updateParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginPatch(resourceGroupName, accountName, updateParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DatabaseAccount']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Creates or updates an Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} createUpdateParameters The parameters to provide for the
 * current database account.
 *
 * @param {string} [createUpdateParameters.kind] Indicates the type of database
 * account. This can only be set at database account creation. Possible values
 * include: 'GlobalDocumentDB', 'MongoDB', 'Parse'
 *
 * @param {object} [createUpdateParameters.consistencyPolicy] The consistency
 * policy for the Cosmos DB account.
 *
 * @param {string}
 * createUpdateParameters.consistencyPolicy.defaultConsistencyLevel The default
 * consistency level and configuration settings of the Cosmos DB account.
 * Possible values include: 'Eventual', 'Session', 'BoundedStaleness',
 * 'Strong', 'ConsistentPrefix'
 *
 * @param {number}
 * [createUpdateParameters.consistencyPolicy.maxStalenessPrefix] When used with
 * the Bounded Staleness consistency level, this value represents the number of
 * stale requests tolerated. Accepted range for this value is 1 –
 * 2,147,483,647. Required when defaultConsistencyPolicy is set to
 * 'BoundedStaleness'.
 *
 * @param {number}
 * [createUpdateParameters.consistencyPolicy.maxIntervalInSeconds] When used
 * with the Bounded Staleness consistency level, this value represents the time
 * amount of staleness (in seconds) tolerated. Accepted range for this value is
 * 5 - 86400. Required when defaultConsistencyPolicy is set to
 * 'BoundedStaleness'.
 *
 * @param {array} createUpdateParameters.locations An array that contains the
 * georeplication locations enabled for the Cosmos DB account.
 *
 * @param {string} [createUpdateParameters.ipRangeFilter] Cosmos DB Firewall
 * Support: This value specifies the set of IP addresses or IP address ranges
 * in CIDR form to be included as the allowed list of client IPs for a given
 * database account. IP addresses/ranges must be comma separated and must not
 * contain any spaces.
 *
 * @param {boolean} [createUpdateParameters.isVirtualNetworkFilterEnabled] Flag
 * to indicate whether to enable/disable Virtual Network ACL rules.
 *
 * @param {boolean} [createUpdateParameters.enableAutomaticFailover] Enables
 * automatic failover of the write region in the rare event that the region is
 * unavailable due to an outage. Automatic failover will result in a new write
 * region for the account and is chosen based on the failover priorities
 * configured for the account.
 *
 * @param {array} [createUpdateParameters.capabilities] List of Cosmos DB
 * capabilities for the account
 *
 * @param {array} [createUpdateParameters.virtualNetworkRules] List of Virtual
 * Network ACL rules configured for the Cosmos DB account.
 *
 * @param {boolean} [createUpdateParameters.enableMultipleWriteLocations]
 * Enables the account to write in multiple locations
 *
 * @param {string} [createUpdateParameters.location] The location of the
 * resource group to which the resource belongs.
 *
 * @param {object} [createUpdateParameters.tags]
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DatabaseAccount} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createOrUpdate(resourceGroupName, accountName, createUpdateParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateOrUpdate(resourceGroupName, accountName, createUpdateParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DatabaseAccount']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Deletes an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteMethod(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginDeleteMethod(resourceGroupName, accountName, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Changes the failover priority for the Azure Cosmos DB database account. A
 * failover priority of 0 indicates a write region. The maximum value for a
 * failover priority = (total number of regions - 1). Failover priority values
 * must be unique for each of the regions in which the database account exists.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} failoverParameters The new failover policies for the
 * database account.
 *
 * @param {array} failoverParameters.failoverPolicies List of failover
 * policies.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _failoverPriorityChange(resourceGroupName, accountName, failoverParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginFailoverPriorityChange(resourceGroupName, accountName, failoverParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Lists all the Azure Cosmos DB database accounts available under the
 * subscription.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DatabaseAccountsListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _list(options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/providers/Microsoft.DocumentDB/databaseAccounts';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DatabaseAccountsListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Lists all the Azure Cosmos DB database accounts available under the given
 * resource group.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DatabaseAccountsListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listByResourceGroup(resourceGroupName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts';
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DatabaseAccountsListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Lists the access keys for the specified Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DatabaseAccountListKeysResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listKeys(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/listKeys';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DatabaseAccountListKeysResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Lists the connection strings for the specified Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DatabaseAccountListConnectionStringsResult}
 *                      for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listConnectionStrings(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/listConnectionStrings';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DatabaseAccountListConnectionStringsResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Offline the specified region for the specified Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} regionParameterForOffline Cosmos DB region to offline for
 * the database account.
 *
 * @param {string} regionParameterForOffline.region Cosmos DB region, with
 * spaces between words and each word capitalized.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _offlineRegion(resourceGroupName, accountName, regionParameterForOffline, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginOfflineRegion(resourceGroupName, accountName, regionParameterForOffline, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Online the specified region for the specified Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} regionParameterForOnline Cosmos DB region to online for the
 * database account.
 *
 * @param {string} regionParameterForOnline.region Cosmos DB region, with
 * spaces between words and each word capitalized.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _onlineRegion(resourceGroupName, accountName, regionParameterForOnline, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginOnlineRegion(resourceGroupName, accountName, regionParameterForOnline, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Lists the read-only access keys for the specified Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DatabaseAccountListReadOnlyKeysResult} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getReadOnlyKeys(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/readonlykeys';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DatabaseAccountListReadOnlyKeysResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Lists the read-only access keys for the specified Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DatabaseAccountListReadOnlyKeysResult} for
 *                      more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listReadOnlyKeys(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/readonlykeys';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DatabaseAccountListReadOnlyKeysResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Regenerates an access key for the specified Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} keyToRegenerate The name of the key to regenerate.
 *
 * @param {string} keyToRegenerate.keyKind The access key to regenerate.
 * Possible values include: 'primary', 'secondary', 'primaryReadonly',
 * 'secondaryReadonly'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _regenerateKey(resourceGroupName, accountName, keyToRegenerate, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginRegenerateKey(resourceGroupName, accountName, keyToRegenerate, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Checks that the Azure Cosmos DB account name already exists. A valid account
 * name may contain only lowercase letters, numbers, and the '-' character, and
 * must be between 3 and 50 characters.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {boolean} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _checkNameExists(accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'providers/Microsoft.DocumentDB/databaseAccountNames/{accountName}';
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'HEAD';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 404) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    result = (statusCode === 200);

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Retrieves the metrics determined by the given filter for the given database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} filter An OData filter expression that describes a subset of
 * metrics to return. The parameters that can be filtered are name.value (name
 * of the metric, can have an or of multiple names), startTime, endTime, and
 * timeGrain. The supported operator is eq.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MetricListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetrics(resourceGroupName, accountName, filter, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (filter === null || filter === undefined || typeof filter.valueOf() !== 'string') {
      throw new Error('filter cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/metrics';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  queryParameters.push('$filter=' + encodeURIComponent(filter));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MetricListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Retrieves the usages (most recent data) for the given database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {string} [options.filter] An OData filter expression that describes a
 * subset of usages to return. The supported parameter is name.value (name of
 * the metric, can have an or of multiple names).
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link UsagesResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listUsages(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  let filter = (options && options.filter !== undefined) ? options.filter : undefined;
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (filter !== null && filter !== undefined && typeof filter.valueOf() !== 'string') {
      throw new Error('filter must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/usages';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (filter !== null && filter !== undefined) {
    queryParameters.push('$filter=' + encodeURIComponent(filter));
  }
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['UsagesResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Retrieves metric definitions for the given database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MetricDefinitionsListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMetricDefinitions(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/metricDefinitions';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MetricDefinitionsListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Lists the SQL databases under an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SqlDatabaseListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSqlDatabases(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/sql/databases';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SqlDatabaseListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets the SQL databases under an existing Azure Cosmos DB database account
 * with the provided name.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SqlDatabase} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSqlDatabase(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/sql/databases/{databaseName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SqlDatabase']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Create or update an Azure Cosmos DB SQL database
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} createUpdateSqlDatabaseParameters The parameters to provide
 * for the current SQL database.
 *
 * @param {object} createUpdateSqlDatabaseParameters.resource The standard JSON
 * format of a SQL database
 *
 * @param {string} createUpdateSqlDatabaseParameters.resource.id Name of the
 * Cosmos DB SQL database
 *
 * @param {object} createUpdateSqlDatabaseParameters.options A key-value pair
 * of options to be applied for the request. This corresponds to the headers
 * sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SqlDatabase} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SqlDatabase']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Deletes an existing Azure Cosmos DB SQL database.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteSqlDatabase(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginDeleteSqlDatabase(resourceGroupName, accountName, databaseName, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Lists the SQL container under an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SqlContainerListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listSqlContainers(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/sql/databases/{databaseName}/containers';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SqlContainerListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets the SQL container under an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} containerName Cosmos DB container name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SqlContainer} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (containerName === null || containerName === undefined || typeof containerName.valueOf() !== 'string') {
      throw new Error('containerName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/sql/databases/{databaseName}/containers/{containerName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  requestUrl = requestUrl.replace('{containerName}', encodeURIComponent(containerName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SqlContainer']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Create or update an Azure Cosmos DB SQL container
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} containerName Cosmos DB container name.
 *
 * @param {object} createUpdateSqlContainerParameters The parameters to provide
 * for the current SQL container.
 *
 * @param {object} createUpdateSqlContainerParameters.resource The standard
 * JSON format of a container
 *
 * @param {string} createUpdateSqlContainerParameters.resource.id Name of the
 * Cosmos DB SQL container
 *
 * @param {object} [createUpdateSqlContainerParameters.resource.indexingPolicy]
 * The configuration of the indexing policy. By default, the indexing is
 * automatic for all document paths within the container
 *
 * @param {boolean}
 * [createUpdateSqlContainerParameters.resource.indexingPolicy.automatic]
 * Indicates if the indexing policy is automatic
 *
 * @param {string}
 * [createUpdateSqlContainerParameters.resource.indexingPolicy.indexingMode]
 * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
 * 'None'
 *
 * @param {array}
 * [createUpdateSqlContainerParameters.resource.indexingPolicy.includedPaths]
 * List of paths to include in the indexing
 *
 * @param {array}
 * [createUpdateSqlContainerParameters.resource.indexingPolicy.excludedPaths]
 * List of paths to exclude from indexing
 *
 * @param {object} [createUpdateSqlContainerParameters.resource.partitionKey]
 * The configuration of the partition key to be used for partitioning data into
 * multiple partitions
 *
 * @param {array}
 * [createUpdateSqlContainerParameters.resource.partitionKey.paths] List of
 * paths using which data within the container can be partitioned
 *
 * @param {string}
 * [createUpdateSqlContainerParameters.resource.partitionKey.kind] Indicates
 * the kind of algorithm used for partitioning. Possible values include:
 * 'Hash', 'Range'
 *
 * @param {number} [createUpdateSqlContainerParameters.resource.defaultTtl]
 * Default time to live
 *
 * @param {object}
 * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy] The unique key
 * policy configuration for specifying uniqueness constraints on documents in
 * the collection in the Azure Cosmos DB service.
 *
 * @param {array}
 * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy.uniqueKeys]
 * List of unique keys on that enforces uniqueness constraint on documents in
 * the collection in the Azure Cosmos DB service.
 *
 * @param {object}
 * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy] The
 * conflict resolution policy for the container.
 *
 * @param {string}
 * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.mode]
 * Indicates the conflict resolution mode. Possible values include:
 * 'LastWriterWins', 'Custom'
 *
 * @param {string}
 * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
 * The conflict resolution path in the case of LastWriterWins mode.
 *
 * @param {string}
 * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
 * The procedure to resolve conflicts in the case of custom mode.
 *
 * @param {object} createUpdateSqlContainerParameters.options A key-value pair
 * of options to be applied for the request. This corresponds to the headers
 * sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SqlContainer} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SqlContainer']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Deletes an existing Azure Cosmos DB SQL container.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} containerName Cosmos DB container name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginDeleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Lists the MongoDB databases under an existing Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MongoDBDatabaseListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMongoDBDatabases(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/mongodb/databases';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MongoDBDatabaseListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets the MongoDB databases under an existing Azure Cosmos DB database
 * account with the provided name.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MongoDBDatabase} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getMongoDBDatabase(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/mongodb/databases/{databaseName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MongoDBDatabase']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Create or updates Azure Cosmos DB MongoDB database
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} createUpdateMongoDBDatabaseParameters The parameters to
 * provide for the current MongoDB database.
 *
 * @param {object} createUpdateMongoDBDatabaseParameters.resource The standard
 * JSON format of a MongoDB database
 *
 * @param {string} createUpdateMongoDBDatabaseParameters.resource.id Name of
 * the Cosmos DB MongoDB database
 *
 * @param {object} createUpdateMongoDBDatabaseParameters.options A key-value
 * pair of options to be applied for the request. This corresponds to the
 * headers sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MongoDBDatabase} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MongoDBDatabase']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Deletes an existing Azure Cosmos DB MongoDB database.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginDeleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Lists the MongoDB collection under an existing Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MongoDBCollectionListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listMongoDBCollections(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/mongodb/databases/{databaseName}/collections';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MongoDBCollectionListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets the MongoDB collection under an existing Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} collectionName Cosmos DB collection name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MongoDBCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (collectionName === null || collectionName === undefined || typeof collectionName.valueOf() !== 'string') {
      throw new Error('collectionName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/mongodb/databases/{databaseName}/collections/{collectionName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  requestUrl = requestUrl.replace('{collectionName}', encodeURIComponent(collectionName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MongoDBCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Create or update an Azure Cosmos DB MongoDB Collection
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} collectionName Cosmos DB collection name.
 *
 * @param {object} createUpdateMongoDBCollectionParameters The parameters to
 * provide for the current MongoDB Collection.
 *
 * @param {object} createUpdateMongoDBCollectionParameters.resource The
 * standard JSON format of a MongoDB collection
 *
 * @param {string} createUpdateMongoDBCollectionParameters.resource.id Name of
 * the Cosmos DB MongoDB collection
 *
 * @param {object} [createUpdateMongoDBCollectionParameters.resource.shardKey]
 * A key-value pair of shard keys to be applied for the request.
 *
 * @param {array} [createUpdateMongoDBCollectionParameters.resource.indexes]
 * List of index keys
 *
 * @param {object} createUpdateMongoDBCollectionParameters.options A key-value
 * pair of options to be applied for the request. This corresponds to the
 * headers sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MongoDBCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MongoDBCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Deletes an existing Azure Cosmos DB MongoDB Collection.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} collectionName Cosmos DB collection name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginDeleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Lists the Tables under an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link TableListResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listTables(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/table/tables';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['TableListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets the Tables under an existing Azure Cosmos DB database account with the
 * provided name.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} tableName Cosmos DB table name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Table} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getTable(resourceGroupName, accountName, tableName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (tableName === null || tableName === undefined || typeof tableName.valueOf() !== 'string') {
      throw new Error('tableName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/table/tables/{tableName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{tableName}', encodeURIComponent(tableName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Table']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Create or update an Azure Cosmos DB Table
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} tableName Cosmos DB table name.
 *
 * @param {object} createUpdateTableParameters The parameters to provide for
 * the current Table.
 *
 * @param {object} createUpdateTableParameters.resource The standard JSON
 * format of a Table
 *
 * @param {string} createUpdateTableParameters.resource.id Name of the Cosmos
 * DB table
 *
 * @param {object} createUpdateTableParameters.options A key-value pair of
 * options to be applied for the request. This corresponds to the headers sent
 * with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Table} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Table']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Deletes an existing Azure Cosmos DB Table.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} tableName Cosmos DB table name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteTable(resourceGroupName, accountName, tableName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginDeleteTable(resourceGroupName, accountName, tableName, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Lists the Cassandra keyspaces under an existing Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CassandraKeyspaceListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listCassandraKeyspaces(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/cassandra/keyspaces';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CassandraKeyspaceListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets the Cassandra keyspaces under an existing Azure Cosmos DB database
 * account with the provided name.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} keyspaceName Cosmos DB keyspace name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CassandraKeyspace} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (keyspaceName === null || keyspaceName === undefined || typeof keyspaceName.valueOf() !== 'string') {
      throw new Error('keyspaceName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/cassandra/keyspaces/{keyspaceName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{keyspaceName}', encodeURIComponent(keyspaceName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CassandraKeyspace']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Create or update an Azure Cosmos DB Cassandra keyspace
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} keyspaceName Cosmos DB keyspace name.
 *
 * @param {object} createUpdateCassandraKeyspaceParameters The parameters to
 * provide for the current Cassandra keyspace.
 *
 * @param {object} createUpdateCassandraKeyspaceParameters.resource The
 * standard JSON format of a Cassandra keyspace
 *
 * @param {string} createUpdateCassandraKeyspaceParameters.resource.id Name of
 * the Cosmos DB Cassandra keyspace
 *
 * @param {object} createUpdateCassandraKeyspaceParameters.options A key-value
 * pair of options to be applied for the request. This corresponds to the
 * headers sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CassandraKeyspace} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CassandraKeyspace']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Deletes an existing Azure Cosmos DB Cassandra keyspace.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} keyspaceName Cosmos DB keyspace name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginDeleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Lists the Cassandra table under an existing Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} keyspaceName Cosmos DB keyspace name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CassandraTableListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listCassandraTables(resourceGroupName, accountName, keyspaceName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (keyspaceName === null || keyspaceName === undefined || typeof keyspaceName.valueOf() !== 'string') {
      throw new Error('keyspaceName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/cassandra/keyspaces/{keyspaceName}/tables';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{keyspaceName}', encodeURIComponent(keyspaceName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CassandraTableListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets the Cassandra table under an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} keyspaceName Cosmos DB keyspace name.
 *
 * @param {string} tableName Cosmos DB table name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CassandraTable} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (keyspaceName === null || keyspaceName === undefined || typeof keyspaceName.valueOf() !== 'string') {
      throw new Error('keyspaceName cannot be null or undefined and it must be of type string.');
    }
    if (tableName === null || tableName === undefined || typeof tableName.valueOf() !== 'string') {
      throw new Error('tableName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/cassandra/keyspaces/{keyspaceName}/tables/{tableName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{keyspaceName}', encodeURIComponent(keyspaceName));
  requestUrl = requestUrl.replace('{tableName}', encodeURIComponent(tableName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CassandraTable']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Create or update an Azure Cosmos DB Cassandra Table
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} keyspaceName Cosmos DB keyspace name.
 *
 * @param {string} tableName Cosmos DB table name.
 *
 * @param {object} createUpdateCassandraTableParameters The parameters to
 * provide for the current Cassandra Table.
 *
 * @param {object} createUpdateCassandraTableParameters.resource The standard
 * JSON format of a Cassandra table
 *
 * @param {string} createUpdateCassandraTableParameters.resource.id Name of the
 * Cosmos DB Cassandra table
 *
 * @param {number} [createUpdateCassandraTableParameters.resource.defaultTtl]
 * Time to live of the Cosmos DB Cassandra table
 *
 * @param {object} [createUpdateCassandraTableParameters.resource.schema]
 * Schema of the Cosmos DB Cassandra table
 *
 * @param {array}
 * [createUpdateCassandraTableParameters.resource.schema.columns] List of
 * Cassandra table columns.
 *
 * @param {array}
 * [createUpdateCassandraTableParameters.resource.schema.partitionKeys] List of
 * partition key.
 *
 * @param {array}
 * [createUpdateCassandraTableParameters.resource.schema.clusterKeys] List of
 * cluster key.
 *
 * @param {object} createUpdateCassandraTableParameters.options A key-value
 * pair of options to be applied for the request. This corresponds to the
 * headers sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CassandraTable} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CassandraTable']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Deletes an existing Azure Cosmos DB Cassandra table.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} keyspaceName Cosmos DB keyspace name.
 *
 * @param {string} tableName Cosmos DB table name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginDeleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Lists the Gremlin databases under an existing Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GremlinDatabaseListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listGremlinDatabases(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/gremlin/databases';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GremlinDatabaseListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets the Gremlin databases under an existing Azure Cosmos DB database
 * account with the provided name.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GremlinDatabase} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getGremlinDatabase(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/gremlin/databases/{databaseName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GremlinDatabase']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Create or update an Azure Cosmos DB Gremlin database
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} createUpdateGremlinDatabaseParameters The parameters to
 * provide for the current Gremlin database.
 *
 * @param {object} createUpdateGremlinDatabaseParameters.resource The standard
 * JSON format of a Gremlin database
 *
 * @param {string} createUpdateGremlinDatabaseParameters.resource.id Name of
 * the Cosmos DB Gremlin database
 *
 * @param {object} createUpdateGremlinDatabaseParameters.options A key-value
 * pair of options to be applied for the request. This corresponds to the
 * headers sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GremlinDatabase} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GremlinDatabase']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Deletes an existing Azure Cosmos DB Gremlin database.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteGremlinDatabase(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginDeleteGremlinDatabase(resourceGroupName, accountName, databaseName, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Lists the Gremlin graph under an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GremlinGraphListResult} for more
 *                      information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _listGremlinGraphs(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/gremlin/databases/{databaseName}/graphs';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GremlinGraphListResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Gets the Gremlin graph under an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} graphName Cosmos DB graph name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GremlinGraph} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _getGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (graphName === null || graphName === undefined || typeof graphName.valueOf() !== 'string') {
      throw new Error('graphName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/gremlin/databases/{databaseName}/graphs/{graphName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  requestUrl = requestUrl.replace('{graphName}', encodeURIComponent(graphName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GremlinGraph']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}


/**
 * Create or update an Azure Cosmos DB Gremlin graph
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} graphName Cosmos DB graph name.
 *
 * @param {object} createUpdateGremlinGraphParameters The parameters to provide
 * for the current Gremlin graph.
 *
 * @param {object} createUpdateGremlinGraphParameters.resource The standard
 * JSON format of a Gremlin graph
 *
 * @param {string} createUpdateGremlinGraphParameters.resource.id Name of the
 * Cosmos DB Gremlin graph
 *
 * @param {object} [createUpdateGremlinGraphParameters.resource.indexingPolicy]
 * The configuration of the indexing policy. By default, the indexing is
 * automatic for all document paths within the graph
 *
 * @param {boolean}
 * [createUpdateGremlinGraphParameters.resource.indexingPolicy.automatic]
 * Indicates if the indexing policy is automatic
 *
 * @param {string}
 * [createUpdateGremlinGraphParameters.resource.indexingPolicy.indexingMode]
 * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
 * 'None'
 *
 * @param {array}
 * [createUpdateGremlinGraphParameters.resource.indexingPolicy.includedPaths]
 * List of paths to include in the indexing
 *
 * @param {array}
 * [createUpdateGremlinGraphParameters.resource.indexingPolicy.excludedPaths]
 * List of paths to exclude from indexing
 *
 * @param {object} [createUpdateGremlinGraphParameters.resource.partitionKey]
 * The configuration of the partition key to be used for partitioning data into
 * multiple partitions
 *
 * @param {array}
 * [createUpdateGremlinGraphParameters.resource.partitionKey.paths] List of
 * paths using which data within the container can be partitioned
 *
 * @param {string}
 * [createUpdateGremlinGraphParameters.resource.partitionKey.kind] Indicates
 * the kind of algorithm used for partitioning. Possible values include:
 * 'Hash', 'Range'
 *
 * @param {number} [createUpdateGremlinGraphParameters.resource.defaultTtl]
 * Default time to live
 *
 * @param {object}
 * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy] The unique key
 * policy configuration for specifying uniqueness constraints on documents in
 * the collection in the Azure Cosmos DB service.
 *
 * @param {array}
 * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy.uniqueKeys]
 * List of unique keys on that enforces uniqueness constraint on documents in
 * the collection in the Azure Cosmos DB service.
 *
 * @param {object}
 * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy] The
 * conflict resolution policy for the graph.
 *
 * @param {string}
 * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.mode]
 * Indicates the conflict resolution mode. Possible values include:
 * 'LastWriterWins', 'Custom'
 *
 * @param {string}
 * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
 * The conflict resolution path in the case of LastWriterWins mode.
 *
 * @param {string}
 * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
 * The procedure to resolve conflicts in the case of custom mode.
 *
 * @param {object} createUpdateGremlinGraphParameters.options A key-value pair
 * of options to be applied for the request. This corresponds to the headers
 * sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GremlinGraph} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _createUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginCreateUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GremlinGraph']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }

      return callback(null, result, httpRequest, response);
    });
  });
}


/**
 * Deletes an existing Azure Cosmos DB Gremlin graph.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} graphName Cosmos DB graph name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _deleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }

  if (!callback) {
    throw new Error('callback cannot be null.');
  }

  // Send request
  this.beginDeleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, (err, parsedResult, httpRequest, response) => {
    if (err) return callback(err);

    let initialResult = new msRest.HttpOperationResponse();
    initialResult.request = httpRequest;
    initialResult.response = response;
    initialResult.body = response.body;
    client.getLongRunningOperationResult(initialResult, options, (err, pollingResult) => {
      if (err) return callback(err);

      // Create Result
      let result = null;

      httpRequest = pollingResult.request;
      response = pollingResult.response;
      let responseBody = pollingResult.body;
      if (responseBody === '') responseBody = null;

      // Deserialize Response

      return callback(null, result, httpRequest, response);
    });
  });
}

/**
 * Patches the properties of an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} updateParameters The tags parameter to patch for the current
 * database account.
 *
 * @param {object} [updateParameters.tags]
 *
 * @param {array} [updateParameters.capabilities] List of Cosmos DB
 * capabilities for the account
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DatabaseAccount} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginPatch(resourceGroupName, accountName, updateParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (updateParameters === null || updateParameters === undefined) {
      throw new Error('updateParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PATCH';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (updateParameters !== null && updateParameters !== undefined) {
      let requestModelMapper = new client.models['DatabaseAccountPatchParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, updateParameters, 'updateParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(updateParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DatabaseAccount']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Creates or updates an Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} createUpdateParameters The parameters to provide for the
 * current database account.
 *
 * @param {string} [createUpdateParameters.kind] Indicates the type of database
 * account. This can only be set at database account creation. Possible values
 * include: 'GlobalDocumentDB', 'MongoDB', 'Parse'
 *
 * @param {object} [createUpdateParameters.consistencyPolicy] The consistency
 * policy for the Cosmos DB account.
 *
 * @param {string}
 * createUpdateParameters.consistencyPolicy.defaultConsistencyLevel The default
 * consistency level and configuration settings of the Cosmos DB account.
 * Possible values include: 'Eventual', 'Session', 'BoundedStaleness',
 * 'Strong', 'ConsistentPrefix'
 *
 * @param {number}
 * [createUpdateParameters.consistencyPolicy.maxStalenessPrefix] When used with
 * the Bounded Staleness consistency level, this value represents the number of
 * stale requests tolerated. Accepted range for this value is 1 –
 * 2,147,483,647. Required when defaultConsistencyPolicy is set to
 * 'BoundedStaleness'.
 *
 * @param {number}
 * [createUpdateParameters.consistencyPolicy.maxIntervalInSeconds] When used
 * with the Bounded Staleness consistency level, this value represents the time
 * amount of staleness (in seconds) tolerated. Accepted range for this value is
 * 5 - 86400. Required when defaultConsistencyPolicy is set to
 * 'BoundedStaleness'.
 *
 * @param {array} createUpdateParameters.locations An array that contains the
 * georeplication locations enabled for the Cosmos DB account.
 *
 * @param {string} [createUpdateParameters.ipRangeFilter] Cosmos DB Firewall
 * Support: This value specifies the set of IP addresses or IP address ranges
 * in CIDR form to be included as the allowed list of client IPs for a given
 * database account. IP addresses/ranges must be comma separated and must not
 * contain any spaces.
 *
 * @param {boolean} [createUpdateParameters.isVirtualNetworkFilterEnabled] Flag
 * to indicate whether to enable/disable Virtual Network ACL rules.
 *
 * @param {boolean} [createUpdateParameters.enableAutomaticFailover] Enables
 * automatic failover of the write region in the rare event that the region is
 * unavailable due to an outage. Automatic failover will result in a new write
 * region for the account and is chosen based on the failover priorities
 * configured for the account.
 *
 * @param {array} [createUpdateParameters.capabilities] List of Cosmos DB
 * capabilities for the account
 *
 * @param {array} [createUpdateParameters.virtualNetworkRules] List of Virtual
 * Network ACL rules configured for the Cosmos DB account.
 *
 * @param {boolean} [createUpdateParameters.enableMultipleWriteLocations]
 * Enables the account to write in multiple locations
 *
 * @param {string} [createUpdateParameters.location] The location of the
 * resource group to which the resource belongs.
 *
 * @param {object} [createUpdateParameters.tags]
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link DatabaseAccount} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateOrUpdate(resourceGroupName, accountName, createUpdateParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  if (createUpdateParameters === null || createUpdateParameters === undefined)
  {
    createUpdateParameters = {};
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (createUpdateParameters === null || createUpdateParameters === undefined) {
      throw new Error('createUpdateParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createUpdateParameters !== null && createUpdateParameters !== undefined) {
      let requestModelMapper = new client.models['DatabaseAccountCreateUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, createUpdateParameters, 'createUpdateParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createUpdateParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['DatabaseAccount']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes an existing Azure Cosmos DB database account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginDeleteMethod(resourceGroupName, accountName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Changes the failover priority for the Azure Cosmos DB database account. A
 * failover priority of 0 indicates a write region. The maximum value for a
 * failover priority = (total number of regions - 1). Failover priority values
 * must be unique for each of the regions in which the database account exists.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} failoverParameters The new failover policies for the
 * database account.
 *
 * @param {array} failoverParameters.failoverPolicies List of failover
 * policies.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginFailoverPriorityChange(resourceGroupName, accountName, failoverParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (failoverParameters === null || failoverParameters === undefined) {
      throw new Error('failoverParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/failoverPriorityChange';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (failoverParameters !== null && failoverParameters !== undefined) {
      let requestModelMapper = new client.models['FailoverPolicies']().mapper();
      requestModel = client.serialize(requestModelMapper, failoverParameters, 'failoverParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(failoverParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Offline the specified region for the specified Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} regionParameterForOffline Cosmos DB region to offline for
 * the database account.
 *
 * @param {string} regionParameterForOffline.region Cosmos DB region, with
 * spaces between words and each word capitalized.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginOfflineRegion(resourceGroupName, accountName, regionParameterForOffline, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (regionParameterForOffline === null || regionParameterForOffline === undefined) {
      throw new Error('regionParameterForOffline cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/offlineRegion';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (regionParameterForOffline !== null && regionParameterForOffline !== undefined) {
      let requestModelMapper = new client.models['RegionForOnlineOffline']().mapper();
      requestModel = client.serialize(requestModelMapper, regionParameterForOffline, 'regionParameterForOffline');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(regionParameterForOffline, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ErrorResponse']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Online the specified region for the specified Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} regionParameterForOnline Cosmos DB region to online for the
 * database account.
 *
 * @param {string} regionParameterForOnline.region Cosmos DB region, with
 * spaces between words and each word capitalized.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginOnlineRegion(resourceGroupName, accountName, regionParameterForOnline, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (regionParameterForOnline === null || regionParameterForOnline === undefined) {
      throw new Error('regionParameterForOnline cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/onlineRegion';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (regionParameterForOnline !== null && regionParameterForOnline !== undefined) {
      let requestModelMapper = new client.models['RegionForOnlineOffline']().mapper();
      requestModel = client.serialize(requestModelMapper, regionParameterForOnline, 'regionParameterForOnline');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(regionParameterForOnline, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          let internalError = null;
          if (parsedErrorResponse.error) internalError = parsedErrorResponse.error;
          error.code = internalError ? internalError.code : parsedErrorResponse.code;
          error.message = internalError ? internalError.message : parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['ErrorResponse']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Regenerates an access key for the specified Azure Cosmos DB database
 * account.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {object} keyToRegenerate The name of the key to regenerate.
 *
 * @param {string} keyToRegenerate.keyKind The access key to regenerate.
 * Possible values include: 'primary', 'secondary', 'primaryReadonly',
 * 'secondaryReadonly'
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginRegenerateKey(resourceGroupName, accountName, keyToRegenerate, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (keyToRegenerate === null || keyToRegenerate === undefined) {
      throw new Error('keyToRegenerate cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/regenerateKey';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (keyToRegenerate !== null && keyToRegenerate !== undefined) {
      let requestModelMapper = new client.models['DatabaseAccountRegenerateKeyParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, keyToRegenerate, 'keyToRegenerate');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(keyToRegenerate, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Create or update an Azure Cosmos DB SQL database
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} createUpdateSqlDatabaseParameters The parameters to provide
 * for the current SQL database.
 *
 * @param {object} createUpdateSqlDatabaseParameters.resource The standard JSON
 * format of a SQL database
 *
 * @param {string} createUpdateSqlDatabaseParameters.resource.id Name of the
 * Cosmos DB SQL database
 *
 * @param {object} createUpdateSqlDatabaseParameters.options A key-value pair
 * of options to be applied for the request. This corresponds to the headers
 * sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SqlDatabase} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (createUpdateSqlDatabaseParameters === null || createUpdateSqlDatabaseParameters === undefined) {
      throw new Error('createUpdateSqlDatabaseParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/sql/databases/{databaseName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createUpdateSqlDatabaseParameters !== null && createUpdateSqlDatabaseParameters !== undefined) {
      let requestModelMapper = new client.models['SqlDatabaseCreateUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, createUpdateSqlDatabaseParameters, 'createUpdateSqlDatabaseParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createUpdateSqlDatabaseParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SqlDatabase']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes an existing Azure Cosmos DB SQL database.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginDeleteSqlDatabase(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/sql/databases/{databaseName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Create or update an Azure Cosmos DB SQL container
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} containerName Cosmos DB container name.
 *
 * @param {object} createUpdateSqlContainerParameters The parameters to provide
 * for the current SQL container.
 *
 * @param {object} createUpdateSqlContainerParameters.resource The standard
 * JSON format of a container
 *
 * @param {string} createUpdateSqlContainerParameters.resource.id Name of the
 * Cosmos DB SQL container
 *
 * @param {object} [createUpdateSqlContainerParameters.resource.indexingPolicy]
 * The configuration of the indexing policy. By default, the indexing is
 * automatic for all document paths within the container
 *
 * @param {boolean}
 * [createUpdateSqlContainerParameters.resource.indexingPolicy.automatic]
 * Indicates if the indexing policy is automatic
 *
 * @param {string}
 * [createUpdateSqlContainerParameters.resource.indexingPolicy.indexingMode]
 * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
 * 'None'
 *
 * @param {array}
 * [createUpdateSqlContainerParameters.resource.indexingPolicy.includedPaths]
 * List of paths to include in the indexing
 *
 * @param {array}
 * [createUpdateSqlContainerParameters.resource.indexingPolicy.excludedPaths]
 * List of paths to exclude from indexing
 *
 * @param {object} [createUpdateSqlContainerParameters.resource.partitionKey]
 * The configuration of the partition key to be used for partitioning data into
 * multiple partitions
 *
 * @param {array}
 * [createUpdateSqlContainerParameters.resource.partitionKey.paths] List of
 * paths using which data within the container can be partitioned
 *
 * @param {string}
 * [createUpdateSqlContainerParameters.resource.partitionKey.kind] Indicates
 * the kind of algorithm used for partitioning. Possible values include:
 * 'Hash', 'Range'
 *
 * @param {number} [createUpdateSqlContainerParameters.resource.defaultTtl]
 * Default time to live
 *
 * @param {object}
 * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy] The unique key
 * policy configuration for specifying uniqueness constraints on documents in
 * the collection in the Azure Cosmos DB service.
 *
 * @param {array}
 * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy.uniqueKeys]
 * List of unique keys on that enforces uniqueness constraint on documents in
 * the collection in the Azure Cosmos DB service.
 *
 * @param {object}
 * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy] The
 * conflict resolution policy for the container.
 *
 * @param {string}
 * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.mode]
 * Indicates the conflict resolution mode. Possible values include:
 * 'LastWriterWins', 'Custom'
 *
 * @param {string}
 * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
 * The conflict resolution path in the case of LastWriterWins mode.
 *
 * @param {string}
 * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
 * The procedure to resolve conflicts in the case of custom mode.
 *
 * @param {object} createUpdateSqlContainerParameters.options A key-value pair
 * of options to be applied for the request. This corresponds to the headers
 * sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link SqlContainer} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (containerName === null || containerName === undefined || typeof containerName.valueOf() !== 'string') {
      throw new Error('containerName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (createUpdateSqlContainerParameters === null || createUpdateSqlContainerParameters === undefined) {
      throw new Error('createUpdateSqlContainerParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/sql/databases/{databaseName}/containers/{containerName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  requestUrl = requestUrl.replace('{containerName}', encodeURIComponent(containerName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createUpdateSqlContainerParameters !== null && createUpdateSqlContainerParameters !== undefined) {
      let requestModelMapper = new client.models['SqlContainerCreateUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, createUpdateSqlContainerParameters, 'createUpdateSqlContainerParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createUpdateSqlContainerParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['SqlContainer']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes an existing Azure Cosmos DB SQL container.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} containerName Cosmos DB container name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginDeleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (containerName === null || containerName === undefined || typeof containerName.valueOf() !== 'string') {
      throw new Error('containerName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/sql/databases/{databaseName}/containers/{containerName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  requestUrl = requestUrl.replace('{containerName}', encodeURIComponent(containerName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Create or updates Azure Cosmos DB MongoDB database
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} createUpdateMongoDBDatabaseParameters The parameters to
 * provide for the current MongoDB database.
 *
 * @param {object} createUpdateMongoDBDatabaseParameters.resource The standard
 * JSON format of a MongoDB database
 *
 * @param {string} createUpdateMongoDBDatabaseParameters.resource.id Name of
 * the Cosmos DB MongoDB database
 *
 * @param {object} createUpdateMongoDBDatabaseParameters.options A key-value
 * pair of options to be applied for the request. This corresponds to the
 * headers sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MongoDBDatabase} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (createUpdateMongoDBDatabaseParameters === null || createUpdateMongoDBDatabaseParameters === undefined) {
      throw new Error('createUpdateMongoDBDatabaseParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/mongodb/databases/{databaseName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createUpdateMongoDBDatabaseParameters !== null && createUpdateMongoDBDatabaseParameters !== undefined) {
      let requestModelMapper = new client.models['MongoDBDatabaseCreateUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, createUpdateMongoDBDatabaseParameters, 'createUpdateMongoDBDatabaseParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createUpdateMongoDBDatabaseParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MongoDBDatabase']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes an existing Azure Cosmos DB MongoDB database.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginDeleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/mongodb/databases/{databaseName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Create or update an Azure Cosmos DB MongoDB Collection
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} collectionName Cosmos DB collection name.
 *
 * @param {object} createUpdateMongoDBCollectionParameters The parameters to
 * provide for the current MongoDB Collection.
 *
 * @param {object} createUpdateMongoDBCollectionParameters.resource The
 * standard JSON format of a MongoDB collection
 *
 * @param {string} createUpdateMongoDBCollectionParameters.resource.id Name of
 * the Cosmos DB MongoDB collection
 *
 * @param {object} [createUpdateMongoDBCollectionParameters.resource.shardKey]
 * A key-value pair of shard keys to be applied for the request.
 *
 * @param {array} [createUpdateMongoDBCollectionParameters.resource.indexes]
 * List of index keys
 *
 * @param {object} createUpdateMongoDBCollectionParameters.options A key-value
 * pair of options to be applied for the request. This corresponds to the
 * headers sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link MongoDBCollection} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (collectionName === null || collectionName === undefined || typeof collectionName.valueOf() !== 'string') {
      throw new Error('collectionName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (createUpdateMongoDBCollectionParameters === null || createUpdateMongoDBCollectionParameters === undefined) {
      throw new Error('createUpdateMongoDBCollectionParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/mongodb/databases/{databaseName}/collections/{collectionName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  requestUrl = requestUrl.replace('{collectionName}', encodeURIComponent(collectionName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createUpdateMongoDBCollectionParameters !== null && createUpdateMongoDBCollectionParameters !== undefined) {
      let requestModelMapper = new client.models['MongoDBCollectionCreateUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, createUpdateMongoDBCollectionParameters, 'createUpdateMongoDBCollectionParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createUpdateMongoDBCollectionParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['MongoDBCollection']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes an existing Azure Cosmos DB MongoDB Collection.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} collectionName Cosmos DB collection name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginDeleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (collectionName === null || collectionName === undefined || typeof collectionName.valueOf() !== 'string') {
      throw new Error('collectionName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/mongodb/databases/{databaseName}/collections/{collectionName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  requestUrl = requestUrl.replace('{collectionName}', encodeURIComponent(collectionName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Create or update an Azure Cosmos DB Table
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} tableName Cosmos DB table name.
 *
 * @param {object} createUpdateTableParameters The parameters to provide for
 * the current Table.
 *
 * @param {object} createUpdateTableParameters.resource The standard JSON
 * format of a Table
 *
 * @param {string} createUpdateTableParameters.resource.id Name of the Cosmos
 * DB table
 *
 * @param {object} createUpdateTableParameters.options A key-value pair of
 * options to be applied for the request. This corresponds to the headers sent
 * with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link Table} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (tableName === null || tableName === undefined || typeof tableName.valueOf() !== 'string') {
      throw new Error('tableName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (createUpdateTableParameters === null || createUpdateTableParameters === undefined) {
      throw new Error('createUpdateTableParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/table/tables/{tableName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{tableName}', encodeURIComponent(tableName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createUpdateTableParameters !== null && createUpdateTableParameters !== undefined) {
      let requestModelMapper = new client.models['TableCreateUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, createUpdateTableParameters, 'createUpdateTableParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createUpdateTableParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['Table']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes an existing Azure Cosmos DB Table.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} tableName Cosmos DB table name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginDeleteTable(resourceGroupName, accountName, tableName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (tableName === null || tableName === undefined || typeof tableName.valueOf() !== 'string') {
      throw new Error('tableName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/table/tables/{tableName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{tableName}', encodeURIComponent(tableName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Create or update an Azure Cosmos DB Cassandra keyspace
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} keyspaceName Cosmos DB keyspace name.
 *
 * @param {object} createUpdateCassandraKeyspaceParameters The parameters to
 * provide for the current Cassandra keyspace.
 *
 * @param {object} createUpdateCassandraKeyspaceParameters.resource The
 * standard JSON format of a Cassandra keyspace
 *
 * @param {string} createUpdateCassandraKeyspaceParameters.resource.id Name of
 * the Cosmos DB Cassandra keyspace
 *
 * @param {object} createUpdateCassandraKeyspaceParameters.options A key-value
 * pair of options to be applied for the request. This corresponds to the
 * headers sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CassandraKeyspace} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (keyspaceName === null || keyspaceName === undefined || typeof keyspaceName.valueOf() !== 'string') {
      throw new Error('keyspaceName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (createUpdateCassandraKeyspaceParameters === null || createUpdateCassandraKeyspaceParameters === undefined) {
      throw new Error('createUpdateCassandraKeyspaceParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/cassandra/keyspaces/{keyspaceName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{keyspaceName}', encodeURIComponent(keyspaceName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createUpdateCassandraKeyspaceParameters !== null && createUpdateCassandraKeyspaceParameters !== undefined) {
      let requestModelMapper = new client.models['CassandraKeyspaceCreateUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, createUpdateCassandraKeyspaceParameters, 'createUpdateCassandraKeyspaceParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createUpdateCassandraKeyspaceParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CassandraKeyspace']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes an existing Azure Cosmos DB Cassandra keyspace.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} keyspaceName Cosmos DB keyspace name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginDeleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (keyspaceName === null || keyspaceName === undefined || typeof keyspaceName.valueOf() !== 'string') {
      throw new Error('keyspaceName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/cassandra/keyspaces/{keyspaceName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{keyspaceName}', encodeURIComponent(keyspaceName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Create or update an Azure Cosmos DB Cassandra Table
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} keyspaceName Cosmos DB keyspace name.
 *
 * @param {string} tableName Cosmos DB table name.
 *
 * @param {object} createUpdateCassandraTableParameters The parameters to
 * provide for the current Cassandra Table.
 *
 * @param {object} createUpdateCassandraTableParameters.resource The standard
 * JSON format of a Cassandra table
 *
 * @param {string} createUpdateCassandraTableParameters.resource.id Name of the
 * Cosmos DB Cassandra table
 *
 * @param {number} [createUpdateCassandraTableParameters.resource.defaultTtl]
 * Time to live of the Cosmos DB Cassandra table
 *
 * @param {object} [createUpdateCassandraTableParameters.resource.schema]
 * Schema of the Cosmos DB Cassandra table
 *
 * @param {array}
 * [createUpdateCassandraTableParameters.resource.schema.columns] List of
 * Cassandra table columns.
 *
 * @param {array}
 * [createUpdateCassandraTableParameters.resource.schema.partitionKeys] List of
 * partition key.
 *
 * @param {array}
 * [createUpdateCassandraTableParameters.resource.schema.clusterKeys] List of
 * cluster key.
 *
 * @param {object} createUpdateCassandraTableParameters.options A key-value
 * pair of options to be applied for the request. This corresponds to the
 * headers sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link CassandraTable} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (keyspaceName === null || keyspaceName === undefined || typeof keyspaceName.valueOf() !== 'string') {
      throw new Error('keyspaceName cannot be null or undefined and it must be of type string.');
    }
    if (tableName === null || tableName === undefined || typeof tableName.valueOf() !== 'string') {
      throw new Error('tableName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (createUpdateCassandraTableParameters === null || createUpdateCassandraTableParameters === undefined) {
      throw new Error('createUpdateCassandraTableParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/cassandra/keyspaces/{keyspaceName}/tables/{tableName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{keyspaceName}', encodeURIComponent(keyspaceName));
  requestUrl = requestUrl.replace('{tableName}', encodeURIComponent(tableName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createUpdateCassandraTableParameters !== null && createUpdateCassandraTableParameters !== undefined) {
      let requestModelMapper = new client.models['CassandraTableCreateUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, createUpdateCassandraTableParameters, 'createUpdateCassandraTableParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createUpdateCassandraTableParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['CassandraTable']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes an existing Azure Cosmos DB Cassandra table.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} keyspaceName Cosmos DB keyspace name.
 *
 * @param {string} tableName Cosmos DB table name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginDeleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (keyspaceName === null || keyspaceName === undefined || typeof keyspaceName.valueOf() !== 'string') {
      throw new Error('keyspaceName cannot be null or undefined and it must be of type string.');
    }
    if (tableName === null || tableName === undefined || typeof tableName.valueOf() !== 'string') {
      throw new Error('tableName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/cassandra/keyspaces/{keyspaceName}/tables/{tableName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{keyspaceName}', encodeURIComponent(keyspaceName));
  requestUrl = requestUrl.replace('{tableName}', encodeURIComponent(tableName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Create or update an Azure Cosmos DB Gremlin database
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} createUpdateGremlinDatabaseParameters The parameters to
 * provide for the current Gremlin database.
 *
 * @param {object} createUpdateGremlinDatabaseParameters.resource The standard
 * JSON format of a Gremlin database
 *
 * @param {string} createUpdateGremlinDatabaseParameters.resource.id Name of
 * the Cosmos DB Gremlin database
 *
 * @param {object} createUpdateGremlinDatabaseParameters.options A key-value
 * pair of options to be applied for the request. This corresponds to the
 * headers sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GremlinDatabase} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (createUpdateGremlinDatabaseParameters === null || createUpdateGremlinDatabaseParameters === undefined) {
      throw new Error('createUpdateGremlinDatabaseParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/gremlin/databases/{databaseName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createUpdateGremlinDatabaseParameters !== null && createUpdateGremlinDatabaseParameters !== undefined) {
      let requestModelMapper = new client.models['GremlinDatabaseCreateUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, createUpdateGremlinDatabaseParameters, 'createUpdateGremlinDatabaseParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createUpdateGremlinDatabaseParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GremlinDatabase']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes an existing Azure Cosmos DB Gremlin database.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginDeleteGremlinDatabase(resourceGroupName, accountName, databaseName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/gremlin/databases/{databaseName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Create or update an Azure Cosmos DB Gremlin graph
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} graphName Cosmos DB graph name.
 *
 * @param {object} createUpdateGremlinGraphParameters The parameters to provide
 * for the current Gremlin graph.
 *
 * @param {object} createUpdateGremlinGraphParameters.resource The standard
 * JSON format of a Gremlin graph
 *
 * @param {string} createUpdateGremlinGraphParameters.resource.id Name of the
 * Cosmos DB Gremlin graph
 *
 * @param {object} [createUpdateGremlinGraphParameters.resource.indexingPolicy]
 * The configuration of the indexing policy. By default, the indexing is
 * automatic for all document paths within the graph
 *
 * @param {boolean}
 * [createUpdateGremlinGraphParameters.resource.indexingPolicy.automatic]
 * Indicates if the indexing policy is automatic
 *
 * @param {string}
 * [createUpdateGremlinGraphParameters.resource.indexingPolicy.indexingMode]
 * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
 * 'None'
 *
 * @param {array}
 * [createUpdateGremlinGraphParameters.resource.indexingPolicy.includedPaths]
 * List of paths to include in the indexing
 *
 * @param {array}
 * [createUpdateGremlinGraphParameters.resource.indexingPolicy.excludedPaths]
 * List of paths to exclude from indexing
 *
 * @param {object} [createUpdateGremlinGraphParameters.resource.partitionKey]
 * The configuration of the partition key to be used for partitioning data into
 * multiple partitions
 *
 * @param {array}
 * [createUpdateGremlinGraphParameters.resource.partitionKey.paths] List of
 * paths using which data within the container can be partitioned
 *
 * @param {string}
 * [createUpdateGremlinGraphParameters.resource.partitionKey.kind] Indicates
 * the kind of algorithm used for partitioning. Possible values include:
 * 'Hash', 'Range'
 *
 * @param {number} [createUpdateGremlinGraphParameters.resource.defaultTtl]
 * Default time to live
 *
 * @param {object}
 * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy] The unique key
 * policy configuration for specifying uniqueness constraints on documents in
 * the collection in the Azure Cosmos DB service.
 *
 * @param {array}
 * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy.uniqueKeys]
 * List of unique keys on that enforces uniqueness constraint on documents in
 * the collection in the Azure Cosmos DB service.
 *
 * @param {object}
 * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy] The
 * conflict resolution policy for the graph.
 *
 * @param {string}
 * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.mode]
 * Indicates the conflict resolution mode. Possible values include:
 * 'LastWriterWins', 'Custom'
 *
 * @param {string}
 * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
 * The conflict resolution path in the case of LastWriterWins mode.
 *
 * @param {string}
 * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
 * The procedure to resolve conflicts in the case of custom mode.
 *
 * @param {object} createUpdateGremlinGraphParameters.options A key-value pair
 * of options to be applied for the request. This corresponds to the headers
 * sent with the request.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object if an error did not occur.
 *                      See {@link GremlinGraph} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginCreateUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (graphName === null || graphName === undefined || typeof graphName.valueOf() !== 'string') {
      throw new Error('graphName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (createUpdateGremlinGraphParameters === null || createUpdateGremlinGraphParameters === undefined) {
      throw new Error('createUpdateGremlinGraphParameters cannot be null or undefined.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/gremlin/databases/{databaseName}/graphs/{graphName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  requestUrl = requestUrl.replace('{graphName}', encodeURIComponent(graphName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  // Serialize Request
  let requestContent = null;
  let requestModel = null;
  try {
    if (createUpdateGremlinGraphParameters !== null && createUpdateGremlinGraphParameters !== undefined) {
      let requestModelMapper = new client.models['GremlinGraphCreateUpdateParameters']().mapper();
      requestModel = client.serialize(requestModelMapper, createUpdateGremlinGraphParameters, 'createUpdateGremlinGraphParameters');
      requestContent = JSON.stringify(requestModel);
    }
  } catch (error) {
    let serializationError = new Error(`Error "${error.message}" occurred in serializing the ` +
        `payload - ${JSON.stringify(createUpdateGremlinGraphParameters, null, 2)}.`);
    return callback(serializationError);
  }
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 200 && statusCode !== 202) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      let parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          let resultMapper = new client.models['GremlinGraph']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        let deserializationError = new Error(`Error ${error} occurred in deserializing the responseBody - ${responseBody}`);
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
}

/**
 * Deletes an existing Azure Cosmos DB Gremlin graph.
 *
 * @param {string} resourceGroupName Name of an Azure resource group.
 *
 * @param {string} accountName Cosmos DB database account name.
 *
 * @param {string} databaseName Cosmos DB database name.
 *
 * @param {string} graphName Cosmos DB graph name.
 *
 * @param {object} [options] Optional Parameters.
 *
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 *
 * @param {function} callback - The callback.
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object if an error did not occur.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
function _beginDeleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, callback) {
   /* jshint validthis: true */
  let client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  // Validate
  try {
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName === null || resourceGroupName === undefined || typeof resourceGroupName.valueOf() !== 'string') {
      throw new Error('resourceGroupName cannot be null or undefined and it must be of type string.');
    }
    if (resourceGroupName !== null && resourceGroupName !== undefined) {
      if (resourceGroupName.length > 90)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MaxLength": 90');
      }
      if (resourceGroupName.length < 1)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "MinLength": 1');
      }
      if (resourceGroupName.match(/^[-\w\._\(\)]+$/) === null)
      {
        throw new Error('"resourceGroupName" should satisfy the constraint - "Pattern": /^[-\w\._\(\)]+$/');
      }
    }
    if (accountName === null || accountName === undefined || typeof accountName.valueOf() !== 'string') {
      throw new Error('accountName cannot be null or undefined and it must be of type string.');
    }
    if (accountName !== null && accountName !== undefined) {
      if (accountName.length > 50)
      {
        throw new Error('"accountName" should satisfy the constraint - "MaxLength": 50');
      }
      if (accountName.length < 3)
      {
        throw new Error('"accountName" should satisfy the constraint - "MinLength": 3');
      }
    }
    if (databaseName === null || databaseName === undefined || typeof databaseName.valueOf() !== 'string') {
      throw new Error('databaseName cannot be null or undefined and it must be of type string.');
    }
    if (graphName === null || graphName === undefined || typeof graphName.valueOf() !== 'string') {
      throw new Error('graphName cannot be null or undefined and it must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  let baseUrl = this.client.baseUri;
  let requestUrl = baseUrl + (baseUrl.endsWith('/') ? '' : '/') + 'subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.DocumentDB/databaseAccounts/{accountName}/apis/gremlin/databases/{databaseName}/graphs/{graphName}';
  requestUrl = requestUrl.replace('{subscriptionId}', encodeURIComponent(this.client.subscriptionId));
  requestUrl = requestUrl.replace('{resourceGroupName}', encodeURIComponent(resourceGroupName));
  requestUrl = requestUrl.replace('{accountName}', encodeURIComponent(accountName));
  requestUrl = requestUrl.replace('{databaseName}', encodeURIComponent(databaseName));
  requestUrl = requestUrl.replace('{graphName}', encodeURIComponent(graphName));
  let queryParameters = [];
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }

  // Create HTTP transport objects
  let httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.url = requestUrl;
  httpRequest.headers = {};
  // Set Headers
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(let headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.body = null;
  // Send Request
  return client.pipeline(httpRequest, (err, response, responseBody) => {
    if (err) {
      return callback(err);
    }
    let statusCode = response.statusCode;
    if (statusCode !== 202 && statusCode !== 204) {
      let error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      let parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          let resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = `Error "${defaultError.message}" occurred in deserializing the responseBody ` +
                         `- "${responseBody}" for the default response.`;
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    let result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
}

/** Class representing a DatabaseAccounts. */
class DatabaseAccounts {
  /**
   * Create a DatabaseAccounts.
   * @param {CosmosDBManagementClient} client Reference to the service client.
   */
  constructor(client) {
    this.client = client;
    this._get = _get;
    this._patch = _patch;
    this._createOrUpdate = _createOrUpdate;
    this._deleteMethod = _deleteMethod;
    this._failoverPriorityChange = _failoverPriorityChange;
    this._list = _list;
    this._listByResourceGroup = _listByResourceGroup;
    this._listKeys = _listKeys;
    this._listConnectionStrings = _listConnectionStrings;
    this._offlineRegion = _offlineRegion;
    this._onlineRegion = _onlineRegion;
    this._getReadOnlyKeys = _getReadOnlyKeys;
    this._listReadOnlyKeys = _listReadOnlyKeys;
    this._regenerateKey = _regenerateKey;
    this._checkNameExists = _checkNameExists;
    this._listMetrics = _listMetrics;
    this._listUsages = _listUsages;
    this._listMetricDefinitions = _listMetricDefinitions;
    this._listSqlDatabases = _listSqlDatabases;
    this._getSqlDatabase = _getSqlDatabase;
    this._createUpdateSqlDatabase = _createUpdateSqlDatabase;
    this._deleteSqlDatabase = _deleteSqlDatabase;
    this._listSqlContainers = _listSqlContainers;
    this._getSqlContainer = _getSqlContainer;
    this._createUpdateSqlContainer = _createUpdateSqlContainer;
    this._deleteSqlContainer = _deleteSqlContainer;
    this._listMongoDBDatabases = _listMongoDBDatabases;
    this._getMongoDBDatabase = _getMongoDBDatabase;
    this._createUpdateMongoDBDatabase = _createUpdateMongoDBDatabase;
    this._deleteMongoDBDatabase = _deleteMongoDBDatabase;
    this._listMongoDBCollections = _listMongoDBCollections;
    this._getMongoDBCollection = _getMongoDBCollection;
    this._createUpdateMongoDBCollection = _createUpdateMongoDBCollection;
    this._deleteMongoDBCollection = _deleteMongoDBCollection;
    this._listTables = _listTables;
    this._getTable = _getTable;
    this._createUpdateTable = _createUpdateTable;
    this._deleteTable = _deleteTable;
    this._listCassandraKeyspaces = _listCassandraKeyspaces;
    this._getCassandraKeyspace = _getCassandraKeyspace;
    this._createUpdateCassandraKeyspace = _createUpdateCassandraKeyspace;
    this._deleteCassandraKeyspace = _deleteCassandraKeyspace;
    this._listCassandraTables = _listCassandraTables;
    this._getCassandraTable = _getCassandraTable;
    this._createUpdateCassandraTable = _createUpdateCassandraTable;
    this._deleteCassandraTable = _deleteCassandraTable;
    this._listGremlinDatabases = _listGremlinDatabases;
    this._getGremlinDatabase = _getGremlinDatabase;
    this._createUpdateGremlinDatabase = _createUpdateGremlinDatabase;
    this._deleteGremlinDatabase = _deleteGremlinDatabase;
    this._listGremlinGraphs = _listGremlinGraphs;
    this._getGremlinGraph = _getGremlinGraph;
    this._createUpdateGremlinGraph = _createUpdateGremlinGraph;
    this._deleteGremlinGraph = _deleteGremlinGraph;
    this._beginPatch = _beginPatch;
    this._beginCreateOrUpdate = _beginCreateOrUpdate;
    this._beginDeleteMethod = _beginDeleteMethod;
    this._beginFailoverPriorityChange = _beginFailoverPriorityChange;
    this._beginOfflineRegion = _beginOfflineRegion;
    this._beginOnlineRegion = _beginOnlineRegion;
    this._beginRegenerateKey = _beginRegenerateKey;
    this._beginCreateUpdateSqlDatabase = _beginCreateUpdateSqlDatabase;
    this._beginDeleteSqlDatabase = _beginDeleteSqlDatabase;
    this._beginCreateUpdateSqlContainer = _beginCreateUpdateSqlContainer;
    this._beginDeleteSqlContainer = _beginDeleteSqlContainer;
    this._beginCreateUpdateMongoDBDatabase = _beginCreateUpdateMongoDBDatabase;
    this._beginDeleteMongoDBDatabase = _beginDeleteMongoDBDatabase;
    this._beginCreateUpdateMongoDBCollection = _beginCreateUpdateMongoDBCollection;
    this._beginDeleteMongoDBCollection = _beginDeleteMongoDBCollection;
    this._beginCreateUpdateTable = _beginCreateUpdateTable;
    this._beginDeleteTable = _beginDeleteTable;
    this._beginCreateUpdateCassandraKeyspace = _beginCreateUpdateCassandraKeyspace;
    this._beginDeleteCassandraKeyspace = _beginDeleteCassandraKeyspace;
    this._beginCreateUpdateCassandraTable = _beginCreateUpdateCassandraTable;
    this._beginDeleteCassandraTable = _beginDeleteCassandraTable;
    this._beginCreateUpdateGremlinDatabase = _beginCreateUpdateGremlinDatabase;
    this._beginDeleteGremlinDatabase = _beginDeleteGremlinDatabase;
    this._beginCreateUpdateGremlinGraph = _beginCreateUpdateGremlinGraph;
    this._beginDeleteGremlinGraph = _beginDeleteGremlinGraph;
  }

  /**
   * Retrieves the properties of an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DatabaseAccount>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._get(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Retrieves the properties of an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DatabaseAccount} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DatabaseAccount} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  get(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._get(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._get(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Patches the properties of an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} updateParameters The tags parameter to patch for the current
   * database account.
   *
   * @param {object} [updateParameters.tags]
   *
   * @param {array} [updateParameters.capabilities] List of Cosmos DB
   * capabilities for the account
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DatabaseAccount>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  patchWithHttpOperationResponse(resourceGroupName, accountName, updateParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._patch(resourceGroupName, accountName, updateParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Patches the properties of an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} updateParameters The tags parameter to patch for the current
   * database account.
   *
   * @param {object} [updateParameters.tags]
   *
   * @param {array} [updateParameters.capabilities] List of Cosmos DB
   * capabilities for the account
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DatabaseAccount} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DatabaseAccount} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  patch(resourceGroupName, accountName, updateParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._patch(resourceGroupName, accountName, updateParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._patch(resourceGroupName, accountName, updateParameters, options, optionalCallback);
    }
  }

  /**
   * Creates or updates an Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} createUpdateParameters The parameters to provide for the
   * current database account.
   *
   * @param {string} [createUpdateParameters.kind] Indicates the type of database
   * account. This can only be set at database account creation. Possible values
   * include: 'GlobalDocumentDB', 'MongoDB', 'Parse'
   *
   * @param {object} [createUpdateParameters.consistencyPolicy] The consistency
   * policy for the Cosmos DB account.
   *
   * @param {string}
   * createUpdateParameters.consistencyPolicy.defaultConsistencyLevel The default
   * consistency level and configuration settings of the Cosmos DB account.
   * Possible values include: 'Eventual', 'Session', 'BoundedStaleness',
   * 'Strong', 'ConsistentPrefix'
   *
   * @param {number}
   * [createUpdateParameters.consistencyPolicy.maxStalenessPrefix] When used with
   * the Bounded Staleness consistency level, this value represents the number of
   * stale requests tolerated. Accepted range for this value is 1 –
   * 2,147,483,647. Required when defaultConsistencyPolicy is set to
   * 'BoundedStaleness'.
   *
   * @param {number}
   * [createUpdateParameters.consistencyPolicy.maxIntervalInSeconds] When used
   * with the Bounded Staleness consistency level, this value represents the time
   * amount of staleness (in seconds) tolerated. Accepted range for this value is
   * 5 - 86400. Required when defaultConsistencyPolicy is set to
   * 'BoundedStaleness'.
   *
   * @param {array} createUpdateParameters.locations An array that contains the
   * georeplication locations enabled for the Cosmos DB account.
   *
   * @param {string} [createUpdateParameters.ipRangeFilter] Cosmos DB Firewall
   * Support: This value specifies the set of IP addresses or IP address ranges
   * in CIDR form to be included as the allowed list of client IPs for a given
   * database account. IP addresses/ranges must be comma separated and must not
   * contain any spaces.
   *
   * @param {boolean} [createUpdateParameters.isVirtualNetworkFilterEnabled] Flag
   * to indicate whether to enable/disable Virtual Network ACL rules.
   *
   * @param {boolean} [createUpdateParameters.enableAutomaticFailover] Enables
   * automatic failover of the write region in the rare event that the region is
   * unavailable due to an outage. Automatic failover will result in a new write
   * region for the account and is chosen based on the failover priorities
   * configured for the account.
   *
   * @param {array} [createUpdateParameters.capabilities] List of Cosmos DB
   * capabilities for the account
   *
   * @param {array} [createUpdateParameters.virtualNetworkRules] List of Virtual
   * Network ACL rules configured for the Cosmos DB account.
   *
   * @param {boolean} [createUpdateParameters.enableMultipleWriteLocations]
   * Enables the account to write in multiple locations
   *
   * @param {string} [createUpdateParameters.location] The location of the
   * resource group to which the resource belongs.
   *
   * @param {object} [createUpdateParameters.tags]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DatabaseAccount>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createOrUpdateWithHttpOperationResponse(resourceGroupName, accountName, createUpdateParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createOrUpdate(resourceGroupName, accountName, createUpdateParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Creates or updates an Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} createUpdateParameters The parameters to provide for the
   * current database account.
   *
   * @param {string} [createUpdateParameters.kind] Indicates the type of database
   * account. This can only be set at database account creation. Possible values
   * include: 'GlobalDocumentDB', 'MongoDB', 'Parse'
   *
   * @param {object} [createUpdateParameters.consistencyPolicy] The consistency
   * policy for the Cosmos DB account.
   *
   * @param {string}
   * createUpdateParameters.consistencyPolicy.defaultConsistencyLevel The default
   * consistency level and configuration settings of the Cosmos DB account.
   * Possible values include: 'Eventual', 'Session', 'BoundedStaleness',
   * 'Strong', 'ConsistentPrefix'
   *
   * @param {number}
   * [createUpdateParameters.consistencyPolicy.maxStalenessPrefix] When used with
   * the Bounded Staleness consistency level, this value represents the number of
   * stale requests tolerated. Accepted range for this value is 1 –
   * 2,147,483,647. Required when defaultConsistencyPolicy is set to
   * 'BoundedStaleness'.
   *
   * @param {number}
   * [createUpdateParameters.consistencyPolicy.maxIntervalInSeconds] When used
   * with the Bounded Staleness consistency level, this value represents the time
   * amount of staleness (in seconds) tolerated. Accepted range for this value is
   * 5 - 86400. Required when defaultConsistencyPolicy is set to
   * 'BoundedStaleness'.
   *
   * @param {array} createUpdateParameters.locations An array that contains the
   * georeplication locations enabled for the Cosmos DB account.
   *
   * @param {string} [createUpdateParameters.ipRangeFilter] Cosmos DB Firewall
   * Support: This value specifies the set of IP addresses or IP address ranges
   * in CIDR form to be included as the allowed list of client IPs for a given
   * database account. IP addresses/ranges must be comma separated and must not
   * contain any spaces.
   *
   * @param {boolean} [createUpdateParameters.isVirtualNetworkFilterEnabled] Flag
   * to indicate whether to enable/disable Virtual Network ACL rules.
   *
   * @param {boolean} [createUpdateParameters.enableAutomaticFailover] Enables
   * automatic failover of the write region in the rare event that the region is
   * unavailable due to an outage. Automatic failover will result in a new write
   * region for the account and is chosen based on the failover priorities
   * configured for the account.
   *
   * @param {array} [createUpdateParameters.capabilities] List of Cosmos DB
   * capabilities for the account
   *
   * @param {array} [createUpdateParameters.virtualNetworkRules] List of Virtual
   * Network ACL rules configured for the Cosmos DB account.
   *
   * @param {boolean} [createUpdateParameters.enableMultipleWriteLocations]
   * Enables the account to write in multiple locations
   *
   * @param {string} [createUpdateParameters.location] The location of the
   * resource group to which the resource belongs.
   *
   * @param {object} [createUpdateParameters.tags]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DatabaseAccount} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DatabaseAccount} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createOrUpdate(resourceGroupName, accountName, createUpdateParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createOrUpdate(resourceGroupName, accountName, createUpdateParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createOrUpdate(resourceGroupName, accountName, createUpdateParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteMethodWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteMethod(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMethod(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteMethod(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteMethod(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Changes the failover priority for the Azure Cosmos DB database account. A
   * failover priority of 0 indicates a write region. The maximum value for a
   * failover priority = (total number of regions - 1). Failover priority values
   * must be unique for each of the regions in which the database account exists.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} failoverParameters The new failover policies for the
   * database account.
   *
   * @param {array} failoverParameters.failoverPolicies List of failover
   * policies.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  failoverPriorityChangeWithHttpOperationResponse(resourceGroupName, accountName, failoverParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._failoverPriorityChange(resourceGroupName, accountName, failoverParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Changes the failover priority for the Azure Cosmos DB database account. A
   * failover priority of 0 indicates a write region. The maximum value for a
   * failover priority = (total number of regions - 1). Failover priority values
   * must be unique for each of the regions in which the database account exists.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} failoverParameters The new failover policies for the
   * database account.
   *
   * @param {array} failoverParameters.failoverPolicies List of failover
   * policies.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  failoverPriorityChange(resourceGroupName, accountName, failoverParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._failoverPriorityChange(resourceGroupName, accountName, failoverParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._failoverPriorityChange(resourceGroupName, accountName, failoverParameters, options, optionalCallback);
    }
  }

  /**
   * Lists all the Azure Cosmos DB database accounts available under the
   * subscription.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DatabaseAccountsListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listWithHttpOperationResponse(options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._list(options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists all the Azure Cosmos DB database accounts available under the
   * subscription.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DatabaseAccountsListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DatabaseAccountsListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  list(options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._list(options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._list(options, optionalCallback);
    }
  }

  /**
   * Lists all the Azure Cosmos DB database accounts available under the given
   * resource group.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DatabaseAccountsListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listByResourceGroupWithHttpOperationResponse(resourceGroupName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listByResourceGroup(resourceGroupName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists all the Azure Cosmos DB database accounts available under the given
   * resource group.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DatabaseAccountsListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DatabaseAccountsListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listByResourceGroup(resourceGroupName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listByResourceGroup(resourceGroupName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listByResourceGroup(resourceGroupName, options, optionalCallback);
    }
  }

  /**
   * Lists the access keys for the specified Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DatabaseAccountListKeysResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listKeysWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listKeys(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the access keys for the specified Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DatabaseAccountListKeysResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DatabaseAccountListKeysResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listKeys(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listKeys(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listKeys(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Lists the connection strings for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DatabaseAccountListConnectionStringsResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listConnectionStringsWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listConnectionStrings(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the connection strings for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DatabaseAccountListConnectionStringsResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DatabaseAccountListConnectionStringsResult}
   *                      for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listConnectionStrings(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listConnectionStrings(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listConnectionStrings(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Offline the specified region for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} regionParameterForOffline Cosmos DB region to offline for
   * the database account.
   *
   * @param {string} regionParameterForOffline.region Cosmos DB region, with
   * spaces between words and each word capitalized.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  offlineRegionWithHttpOperationResponse(resourceGroupName, accountName, regionParameterForOffline, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._offlineRegion(resourceGroupName, accountName, regionParameterForOffline, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Offline the specified region for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} regionParameterForOffline Cosmos DB region to offline for
   * the database account.
   *
   * @param {string} regionParameterForOffline.region Cosmos DB region, with
   * spaces between words and each word capitalized.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  offlineRegion(resourceGroupName, accountName, regionParameterForOffline, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._offlineRegion(resourceGroupName, accountName, regionParameterForOffline, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._offlineRegion(resourceGroupName, accountName, regionParameterForOffline, options, optionalCallback);
    }
  }

  /**
   * Online the specified region for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} regionParameterForOnline Cosmos DB region to online for the
   * database account.
   *
   * @param {string} regionParameterForOnline.region Cosmos DB region, with
   * spaces between words and each word capitalized.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  onlineRegionWithHttpOperationResponse(resourceGroupName, accountName, regionParameterForOnline, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._onlineRegion(resourceGroupName, accountName, regionParameterForOnline, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Online the specified region for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} regionParameterForOnline Cosmos DB region to online for the
   * database account.
   *
   * @param {string} regionParameterForOnline.region Cosmos DB region, with
   * spaces between words and each word capitalized.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  onlineRegion(resourceGroupName, accountName, regionParameterForOnline, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._onlineRegion(resourceGroupName, accountName, regionParameterForOnline, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._onlineRegion(resourceGroupName, accountName, regionParameterForOnline, options, optionalCallback);
    }
  }

  /**
   * Lists the read-only access keys for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DatabaseAccountListReadOnlyKeysResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getReadOnlyKeysWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getReadOnlyKeys(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the read-only access keys for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DatabaseAccountListReadOnlyKeysResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DatabaseAccountListReadOnlyKeysResult} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getReadOnlyKeys(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getReadOnlyKeys(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getReadOnlyKeys(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Lists the read-only access keys for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DatabaseAccountListReadOnlyKeysResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listReadOnlyKeysWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listReadOnlyKeys(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the read-only access keys for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DatabaseAccountListReadOnlyKeysResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DatabaseAccountListReadOnlyKeysResult} for
   *                      more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listReadOnlyKeys(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listReadOnlyKeys(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listReadOnlyKeys(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Regenerates an access key for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} keyToRegenerate The name of the key to regenerate.
   *
   * @param {string} keyToRegenerate.keyKind The access key to regenerate.
   * Possible values include: 'primary', 'secondary', 'primaryReadonly',
   * 'secondaryReadonly'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  regenerateKeyWithHttpOperationResponse(resourceGroupName, accountName, keyToRegenerate, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._regenerateKey(resourceGroupName, accountName, keyToRegenerate, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Regenerates an access key for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} keyToRegenerate The name of the key to regenerate.
   *
   * @param {string} keyToRegenerate.keyKind The access key to regenerate.
   * Possible values include: 'primary', 'secondary', 'primaryReadonly',
   * 'secondaryReadonly'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  regenerateKey(resourceGroupName, accountName, keyToRegenerate, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._regenerateKey(resourceGroupName, accountName, keyToRegenerate, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._regenerateKey(resourceGroupName, accountName, keyToRegenerate, options, optionalCallback);
    }
  }

  /**
   * Checks that the Azure Cosmos DB account name already exists. A valid account
   * name may contain only lowercase letters, numbers, and the '-' character, and
   * must be between 3 and 50 characters.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Boolean>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  checkNameExistsWithHttpOperationResponse(accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._checkNameExists(accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Checks that the Azure Cosmos DB account name already exists. A valid account
   * name may contain only lowercase letters, numbers, and the '-' character, and
   * must be between 3 and 50 characters.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Boolean} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {boolean} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  checkNameExists(accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._checkNameExists(accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._checkNameExists(accountName, options, optionalCallback);
    }
  }

  /**
   * Retrieves the metrics determined by the given filter for the given database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} filter An OData filter expression that describes a subset of
   * metrics to return. The parameters that can be filtered are name.value (name
   * of the metric, can have an or of multiple names), startTime, endTime, and
   * timeGrain. The supported operator is eq.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MetricListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricsWithHttpOperationResponse(resourceGroupName, accountName, filter, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetrics(resourceGroupName, accountName, filter, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Retrieves the metrics determined by the given filter for the given database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} filter An OData filter expression that describes a subset of
   * metrics to return. The parameters that can be filtered are name.value (name
   * of the metric, can have an or of multiple names), startTime, endTime, and
   * timeGrain. The supported operator is eq.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MetricListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MetricListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetrics(resourceGroupName, accountName, filter, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetrics(resourceGroupName, accountName, filter, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetrics(resourceGroupName, accountName, filter, options, optionalCallback);
    }
  }

  /**
   * Retrieves the usages (most recent data) for the given database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] An OData filter expression that describes a
   * subset of usages to return. The supported parameter is name.value (name of
   * the metric, can have an or of multiple names).
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<UsagesResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listUsagesWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listUsages(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Retrieves the usages (most recent data) for the given database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {string} [options.filter] An OData filter expression that describes a
   * subset of usages to return. The supported parameter is name.value (name of
   * the metric, can have an or of multiple names).
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {UsagesResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link UsagesResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listUsages(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listUsages(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listUsages(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Retrieves metric definitions for the given database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MetricDefinitionsListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMetricDefinitionsWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMetricDefinitions(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Retrieves metric definitions for the given database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MetricDefinitionsListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MetricDefinitionsListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMetricDefinitions(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMetricDefinitions(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMetricDefinitions(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Lists the SQL databases under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SqlDatabaseListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSqlDatabasesWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSqlDatabases(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the SQL databases under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SqlDatabaseListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SqlDatabaseListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSqlDatabases(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSqlDatabases(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSqlDatabases(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Gets the SQL databases under an existing Azure Cosmos DB database account
   * with the provided name.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SqlDatabase>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSqlDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSqlDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets the SQL databases under an existing Azure Cosmos DB database account
   * with the provided name.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SqlDatabase} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SqlDatabase} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSqlDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSqlDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSqlDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB SQL database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateSqlDatabaseParameters The parameters to provide
   * for the current SQL database.
   *
   * @param {object} createUpdateSqlDatabaseParameters.resource The standard JSON
   * format of a SQL database
   *
   * @param {string} createUpdateSqlDatabaseParameters.resource.id Name of the
   * Cosmos DB SQL database
   *
   * @param {object} createUpdateSqlDatabaseParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SqlDatabase>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createUpdateSqlDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB SQL database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateSqlDatabaseParameters The parameters to provide
   * for the current SQL database.
   *
   * @param {object} createUpdateSqlDatabaseParameters.resource The standard JSON
   * format of a SQL database
   *
   * @param {string} createUpdateSqlDatabaseParameters.resource.id Name of the
   * Cosmos DB SQL database
   *
   * @param {object} createUpdateSqlDatabaseParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SqlDatabase} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SqlDatabase} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteSqlDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteSqlDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSqlDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteSqlDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteSqlDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Lists the SQL container under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SqlContainerListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listSqlContainersWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listSqlContainers(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the SQL container under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SqlContainerListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SqlContainerListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listSqlContainers(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listSqlContainers(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listSqlContainers(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Gets the SQL container under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} containerName Cosmos DB container name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SqlContainer>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getSqlContainerWithHttpOperationResponse(resourceGroupName, accountName, databaseName, containerName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets the SQL container under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} containerName Cosmos DB container name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SqlContainer} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SqlContainer} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB SQL container
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} containerName Cosmos DB container name.
   *
   * @param {object} createUpdateSqlContainerParameters The parameters to provide
   * for the current SQL container.
   *
   * @param {object} createUpdateSqlContainerParameters.resource The standard
   * JSON format of a container
   *
   * @param {string} createUpdateSqlContainerParameters.resource.id Name of the
   * Cosmos DB SQL container
   *
   * @param {object} [createUpdateSqlContainerParameters.resource.indexingPolicy]
   * The configuration of the indexing policy. By default, the indexing is
   * automatic for all document paths within the container
   *
   * @param {boolean}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.automatic]
   * Indicates if the indexing policy is automatic
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.indexingMode]
   * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
   * 'None'
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.includedPaths]
   * List of paths to include in the indexing
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.excludedPaths]
   * List of paths to exclude from indexing
   *
   * @param {object} [createUpdateSqlContainerParameters.resource.partitionKey]
   * The configuration of the partition key to be used for partitioning data into
   * multiple partitions
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.partitionKey.paths] List of
   * paths using which data within the container can be partitioned
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.partitionKey.kind] Indicates
   * the kind of algorithm used for partitioning. Possible values include:
   * 'Hash', 'Range'
   *
   * @param {number} [createUpdateSqlContainerParameters.resource.defaultTtl]
   * Default time to live
   *
   * @param {object}
   * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy] The unique key
   * policy configuration for specifying uniqueness constraints on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy.uniqueKeys]
   * List of unique keys on that enforces uniqueness constraint on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {object}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy] The
   * conflict resolution policy for the container.
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.mode]
   * Indicates the conflict resolution mode. Possible values include:
   * 'LastWriterWins', 'Custom'
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
   * The conflict resolution path in the case of LastWriterWins mode.
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
   * The procedure to resolve conflicts in the case of custom mode.
   *
   * @param {object} createUpdateSqlContainerParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SqlContainer>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createUpdateSqlContainerWithHttpOperationResponse(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB SQL container
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} containerName Cosmos DB container name.
   *
   * @param {object} createUpdateSqlContainerParameters The parameters to provide
   * for the current SQL container.
   *
   * @param {object} createUpdateSqlContainerParameters.resource The standard
   * JSON format of a container
   *
   * @param {string} createUpdateSqlContainerParameters.resource.id Name of the
   * Cosmos DB SQL container
   *
   * @param {object} [createUpdateSqlContainerParameters.resource.indexingPolicy]
   * The configuration of the indexing policy. By default, the indexing is
   * automatic for all document paths within the container
   *
   * @param {boolean}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.automatic]
   * Indicates if the indexing policy is automatic
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.indexingMode]
   * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
   * 'None'
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.includedPaths]
   * List of paths to include in the indexing
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.excludedPaths]
   * List of paths to exclude from indexing
   *
   * @param {object} [createUpdateSqlContainerParameters.resource.partitionKey]
   * The configuration of the partition key to be used for partitioning data into
   * multiple partitions
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.partitionKey.paths] List of
   * paths using which data within the container can be partitioned
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.partitionKey.kind] Indicates
   * the kind of algorithm used for partitioning. Possible values include:
   * 'Hash', 'Range'
   *
   * @param {number} [createUpdateSqlContainerParameters.resource.defaultTtl]
   * Default time to live
   *
   * @param {object}
   * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy] The unique key
   * policy configuration for specifying uniqueness constraints on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy.uniqueKeys]
   * List of unique keys on that enforces uniqueness constraint on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {object}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy] The
   * conflict resolution policy for the container.
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.mode]
   * Indicates the conflict resolution mode. Possible values include:
   * 'LastWriterWins', 'Custom'
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
   * The conflict resolution path in the case of LastWriterWins mode.
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
   * The procedure to resolve conflicts in the case of custom mode.
   *
   * @param {object} createUpdateSqlContainerParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SqlContainer} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SqlContainer} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL container.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} containerName Cosmos DB container name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteSqlContainerWithHttpOperationResponse(resourceGroupName, accountName, databaseName, containerName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL container.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} containerName Cosmos DB container name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, optionalCallback);
    }
  }

  /**
   * Lists the MongoDB databases under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MongoDBDatabaseListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMongoDBDatabasesWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMongoDBDatabases(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the MongoDB databases under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MongoDBDatabaseListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MongoDBDatabaseListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMongoDBDatabases(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMongoDBDatabases(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMongoDBDatabases(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Gets the MongoDB databases under an existing Azure Cosmos DB database
   * account with the provided name.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MongoDBDatabase>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getMongoDBDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getMongoDBDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets the MongoDB databases under an existing Azure Cosmos DB database
   * account with the provided name.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MongoDBDatabase} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MongoDBDatabase} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getMongoDBDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getMongoDBDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getMongoDBDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateMongoDBDatabaseParameters The parameters to
   * provide for the current MongoDB database.
   *
   * @param {object} createUpdateMongoDBDatabaseParameters.resource The standard
   * JSON format of a MongoDB database
   *
   * @param {string} createUpdateMongoDBDatabaseParameters.resource.id Name of
   * the Cosmos DB MongoDB database
   *
   * @param {object} createUpdateMongoDBDatabaseParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MongoDBDatabase>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createUpdateMongoDBDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateMongoDBDatabaseParameters The parameters to
   * provide for the current MongoDB database.
   *
   * @param {object} createUpdateMongoDBDatabaseParameters.resource The standard
   * JSON format of a MongoDB database
   *
   * @param {string} createUpdateMongoDBDatabaseParameters.resource.id Name of
   * the Cosmos DB MongoDB database
   *
   * @param {object} createUpdateMongoDBDatabaseParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MongoDBDatabase} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MongoDBDatabase} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteMongoDBDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Lists the MongoDB collection under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MongoDBCollectionListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listMongoDBCollectionsWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listMongoDBCollections(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the MongoDB collection under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MongoDBCollectionListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MongoDBCollectionListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listMongoDBCollections(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listMongoDBCollections(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listMongoDBCollections(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Gets the MongoDB collection under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} collectionName Cosmos DB collection name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MongoDBCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getMongoDBCollectionWithHttpOperationResponse(resourceGroupName, accountName, databaseName, collectionName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets the MongoDB collection under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} collectionName Cosmos DB collection name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MongoDBCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MongoDBCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} collectionName Cosmos DB collection name.
   *
   * @param {object} createUpdateMongoDBCollectionParameters The parameters to
   * provide for the current MongoDB Collection.
   *
   * @param {object} createUpdateMongoDBCollectionParameters.resource The
   * standard JSON format of a MongoDB collection
   *
   * @param {string} createUpdateMongoDBCollectionParameters.resource.id Name of
   * the Cosmos DB MongoDB collection
   *
   * @param {object} [createUpdateMongoDBCollectionParameters.resource.shardKey]
   * A key-value pair of shard keys to be applied for the request.
   *
   * @param {array} [createUpdateMongoDBCollectionParameters.resource.indexes]
   * List of index keys
   *
   * @param {object} createUpdateMongoDBCollectionParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MongoDBCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createUpdateMongoDBCollectionWithHttpOperationResponse(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} collectionName Cosmos DB collection name.
   *
   * @param {object} createUpdateMongoDBCollectionParameters The parameters to
   * provide for the current MongoDB Collection.
   *
   * @param {object} createUpdateMongoDBCollectionParameters.resource The
   * standard JSON format of a MongoDB collection
   *
   * @param {string} createUpdateMongoDBCollectionParameters.resource.id Name of
   * the Cosmos DB MongoDB collection
   *
   * @param {object} [createUpdateMongoDBCollectionParameters.resource.shardKey]
   * A key-value pair of shard keys to be applied for the request.
   *
   * @param {array} [createUpdateMongoDBCollectionParameters.resource.indexes]
   * List of index keys
   *
   * @param {object} createUpdateMongoDBCollectionParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MongoDBCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MongoDBCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} collectionName Cosmos DB collection name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteMongoDBCollectionWithHttpOperationResponse(resourceGroupName, accountName, databaseName, collectionName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} collectionName Cosmos DB collection name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, optionalCallback);
    }
  }

  /**
   * Lists the Tables under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<TableListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listTablesWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listTables(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the Tables under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {TableListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link TableListResult} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listTables(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listTables(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listTables(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Gets the Tables under an existing Azure Cosmos DB database account with the
   * provided name.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Table>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getTableWithHttpOperationResponse(resourceGroupName, accountName, tableName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getTable(resourceGroupName, accountName, tableName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets the Tables under an existing Azure Cosmos DB database account with the
   * provided name.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Table} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Table} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getTable(resourceGroupName, accountName, tableName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getTable(resourceGroupName, accountName, tableName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getTable(resourceGroupName, accountName, tableName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB Table
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} createUpdateTableParameters The parameters to provide for
   * the current Table.
   *
   * @param {object} createUpdateTableParameters.resource The standard JSON
   * format of a Table
   *
   * @param {string} createUpdateTableParameters.resource.id Name of the Cosmos
   * DB table
   *
   * @param {object} createUpdateTableParameters.options A key-value pair of
   * options to be applied for the request. This corresponds to the headers sent
   * with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Table>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createUpdateTableWithHttpOperationResponse(resourceGroupName, accountName, tableName, createUpdateTableParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB Table
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} createUpdateTableParameters The parameters to provide for
   * the current Table.
   *
   * @param {object} createUpdateTableParameters.resource The standard JSON
   * format of a Table
   *
   * @param {string} createUpdateTableParameters.resource.id Name of the Cosmos
   * DB table
   *
   * @param {object} createUpdateTableParameters.options A key-value pair of
   * options to be applied for the request. This corresponds to the headers sent
   * with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Table} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Table} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB Table.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteTableWithHttpOperationResponse(resourceGroupName, accountName, tableName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteTable(resourceGroupName, accountName, tableName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB Table.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteTable(resourceGroupName, accountName, tableName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteTable(resourceGroupName, accountName, tableName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteTable(resourceGroupName, accountName, tableName, options, optionalCallback);
    }
  }

  /**
   * Lists the Cassandra keyspaces under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CassandraKeyspaceListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listCassandraKeyspacesWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listCassandraKeyspaces(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the Cassandra keyspaces under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CassandraKeyspaceListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CassandraKeyspaceListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listCassandraKeyspaces(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listCassandraKeyspaces(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listCassandraKeyspaces(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Gets the Cassandra keyspaces under an existing Azure Cosmos DB database
   * account with the provided name.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CassandraKeyspace>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCassandraKeyspaceWithHttpOperationResponse(resourceGroupName, accountName, keyspaceName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets the Cassandra keyspaces under an existing Azure Cosmos DB database
   * account with the provided name.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CassandraKeyspace} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CassandraKeyspace} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB Cassandra keyspace
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} createUpdateCassandraKeyspaceParameters The parameters to
   * provide for the current Cassandra keyspace.
   *
   * @param {object} createUpdateCassandraKeyspaceParameters.resource The
   * standard JSON format of a Cassandra keyspace
   *
   * @param {string} createUpdateCassandraKeyspaceParameters.resource.id Name of
   * the Cosmos DB Cassandra keyspace
   *
   * @param {object} createUpdateCassandraKeyspaceParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CassandraKeyspace>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createUpdateCassandraKeyspaceWithHttpOperationResponse(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB Cassandra keyspace
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} createUpdateCassandraKeyspaceParameters The parameters to
   * provide for the current Cassandra keyspace.
   *
   * @param {object} createUpdateCassandraKeyspaceParameters.resource The
   * standard JSON format of a Cassandra keyspace
   *
   * @param {string} createUpdateCassandraKeyspaceParameters.resource.id Name of
   * the Cosmos DB Cassandra keyspace
   *
   * @param {object} createUpdateCassandraKeyspaceParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CassandraKeyspace} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CassandraKeyspace} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB Cassandra keyspace.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteCassandraKeyspaceWithHttpOperationResponse(resourceGroupName, accountName, keyspaceName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB Cassandra keyspace.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, optionalCallback);
    }
  }

  /**
   * Lists the Cassandra table under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CassandraTableListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listCassandraTablesWithHttpOperationResponse(resourceGroupName, accountName, keyspaceName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listCassandraTables(resourceGroupName, accountName, keyspaceName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the Cassandra table under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CassandraTableListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CassandraTableListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listCassandraTables(resourceGroupName, accountName, keyspaceName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listCassandraTables(resourceGroupName, accountName, keyspaceName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listCassandraTables(resourceGroupName, accountName, keyspaceName, options, optionalCallback);
    }
  }

  /**
   * Gets the Cassandra table under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CassandraTable>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getCassandraTableWithHttpOperationResponse(resourceGroupName, accountName, keyspaceName, tableName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets the Cassandra table under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CassandraTable} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CassandraTable} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB Cassandra Table
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} createUpdateCassandraTableParameters The parameters to
   * provide for the current Cassandra Table.
   *
   * @param {object} createUpdateCassandraTableParameters.resource The standard
   * JSON format of a Cassandra table
   *
   * @param {string} createUpdateCassandraTableParameters.resource.id Name of the
   * Cosmos DB Cassandra table
   *
   * @param {number} [createUpdateCassandraTableParameters.resource.defaultTtl]
   * Time to live of the Cosmos DB Cassandra table
   *
   * @param {object} [createUpdateCassandraTableParameters.resource.schema]
   * Schema of the Cosmos DB Cassandra table
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.columns] List of
   * Cassandra table columns.
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.partitionKeys] List of
   * partition key.
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.clusterKeys] List of
   * cluster key.
   *
   * @param {object} createUpdateCassandraTableParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CassandraTable>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createUpdateCassandraTableWithHttpOperationResponse(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB Cassandra Table
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} createUpdateCassandraTableParameters The parameters to
   * provide for the current Cassandra Table.
   *
   * @param {object} createUpdateCassandraTableParameters.resource The standard
   * JSON format of a Cassandra table
   *
   * @param {string} createUpdateCassandraTableParameters.resource.id Name of the
   * Cosmos DB Cassandra table
   *
   * @param {number} [createUpdateCassandraTableParameters.resource.defaultTtl]
   * Time to live of the Cosmos DB Cassandra table
   *
   * @param {object} [createUpdateCassandraTableParameters.resource.schema]
   * Schema of the Cosmos DB Cassandra table
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.columns] List of
   * Cassandra table columns.
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.partitionKeys] List of
   * partition key.
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.clusterKeys] List of
   * cluster key.
   *
   * @param {object} createUpdateCassandraTableParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CassandraTable} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CassandraTable} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB Cassandra table.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteCassandraTableWithHttpOperationResponse(resourceGroupName, accountName, keyspaceName, tableName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB Cassandra table.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, optionalCallback);
    }
  }

  /**
   * Lists the Gremlin databases under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GremlinDatabaseListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listGremlinDatabasesWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listGremlinDatabases(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the Gremlin databases under an existing Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GremlinDatabaseListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GremlinDatabaseListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listGremlinDatabases(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listGremlinDatabases(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listGremlinDatabases(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Gets the Gremlin databases under an existing Azure Cosmos DB database
   * account with the provided name.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GremlinDatabase>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getGremlinDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getGremlinDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets the Gremlin databases under an existing Azure Cosmos DB database
   * account with the provided name.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GremlinDatabase} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GremlinDatabase} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getGremlinDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getGremlinDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getGremlinDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB Gremlin database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateGremlinDatabaseParameters The parameters to
   * provide for the current Gremlin database.
   *
   * @param {object} createUpdateGremlinDatabaseParameters.resource The standard
   * JSON format of a Gremlin database
   *
   * @param {string} createUpdateGremlinDatabaseParameters.resource.id Name of
   * the Cosmos DB Gremlin database
   *
   * @param {object} createUpdateGremlinDatabaseParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GremlinDatabase>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createUpdateGremlinDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB Gremlin database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateGremlinDatabaseParameters The parameters to
   * provide for the current Gremlin database.
   *
   * @param {object} createUpdateGremlinDatabaseParameters.resource The standard
   * JSON format of a Gremlin database
   *
   * @param {string} createUpdateGremlinDatabaseParameters.resource.id Name of
   * the Cosmos DB Gremlin database
   *
   * @param {object} createUpdateGremlinDatabaseParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GremlinDatabase} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GremlinDatabase} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB Gremlin database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteGremlinDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteGremlinDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB Gremlin database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGremlinDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteGremlinDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteGremlinDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Lists the Gremlin graph under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GremlinGraphListResult>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  listGremlinGraphsWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._listGremlinGraphs(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Lists the Gremlin graph under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GremlinGraphListResult} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GremlinGraphListResult} for more
   *                      information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  listGremlinGraphs(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._listGremlinGraphs(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._listGremlinGraphs(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Gets the Gremlin graph under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} graphName Cosmos DB graph name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GremlinGraph>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  getGremlinGraphWithHttpOperationResponse(resourceGroupName, accountName, databaseName, graphName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._getGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Gets the Gremlin graph under an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} graphName Cosmos DB graph name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GremlinGraph} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GremlinGraph} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  getGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._getGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._getGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB Gremlin graph
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} graphName Cosmos DB graph name.
   *
   * @param {object} createUpdateGremlinGraphParameters The parameters to provide
   * for the current Gremlin graph.
   *
   * @param {object} createUpdateGremlinGraphParameters.resource The standard
   * JSON format of a Gremlin graph
   *
   * @param {string} createUpdateGremlinGraphParameters.resource.id Name of the
   * Cosmos DB Gremlin graph
   *
   * @param {object} [createUpdateGremlinGraphParameters.resource.indexingPolicy]
   * The configuration of the indexing policy. By default, the indexing is
   * automatic for all document paths within the graph
   *
   * @param {boolean}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.automatic]
   * Indicates if the indexing policy is automatic
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.indexingMode]
   * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
   * 'None'
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.includedPaths]
   * List of paths to include in the indexing
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.excludedPaths]
   * List of paths to exclude from indexing
   *
   * @param {object} [createUpdateGremlinGraphParameters.resource.partitionKey]
   * The configuration of the partition key to be used for partitioning data into
   * multiple partitions
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.partitionKey.paths] List of
   * paths using which data within the container can be partitioned
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.partitionKey.kind] Indicates
   * the kind of algorithm used for partitioning. Possible values include:
   * 'Hash', 'Range'
   *
   * @param {number} [createUpdateGremlinGraphParameters.resource.defaultTtl]
   * Default time to live
   *
   * @param {object}
   * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy] The unique key
   * policy configuration for specifying uniqueness constraints on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy.uniqueKeys]
   * List of unique keys on that enforces uniqueness constraint on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {object}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy] The
   * conflict resolution policy for the graph.
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.mode]
   * Indicates the conflict resolution mode. Possible values include:
   * 'LastWriterWins', 'Custom'
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
   * The conflict resolution path in the case of LastWriterWins mode.
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
   * The procedure to resolve conflicts in the case of custom mode.
   *
   * @param {object} createUpdateGremlinGraphParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GremlinGraph>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  createUpdateGremlinGraphWithHttpOperationResponse(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._createUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB Gremlin graph
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} graphName Cosmos DB graph name.
   *
   * @param {object} createUpdateGremlinGraphParameters The parameters to provide
   * for the current Gremlin graph.
   *
   * @param {object} createUpdateGremlinGraphParameters.resource The standard
   * JSON format of a Gremlin graph
   *
   * @param {string} createUpdateGremlinGraphParameters.resource.id Name of the
   * Cosmos DB Gremlin graph
   *
   * @param {object} [createUpdateGremlinGraphParameters.resource.indexingPolicy]
   * The configuration of the indexing policy. By default, the indexing is
   * automatic for all document paths within the graph
   *
   * @param {boolean}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.automatic]
   * Indicates if the indexing policy is automatic
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.indexingMode]
   * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
   * 'None'
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.includedPaths]
   * List of paths to include in the indexing
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.excludedPaths]
   * List of paths to exclude from indexing
   *
   * @param {object} [createUpdateGremlinGraphParameters.resource.partitionKey]
   * The configuration of the partition key to be used for partitioning data into
   * multiple partitions
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.partitionKey.paths] List of
   * paths using which data within the container can be partitioned
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.partitionKey.kind] Indicates
   * the kind of algorithm used for partitioning. Possible values include:
   * 'Hash', 'Range'
   *
   * @param {number} [createUpdateGremlinGraphParameters.resource.defaultTtl]
   * Default time to live
   *
   * @param {object}
   * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy] The unique key
   * policy configuration for specifying uniqueness constraints on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy.uniqueKeys]
   * List of unique keys on that enforces uniqueness constraint on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {object}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy] The
   * conflict resolution policy for the graph.
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.mode]
   * Indicates the conflict resolution mode. Possible values include:
   * 'LastWriterWins', 'Custom'
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
   * The conflict resolution path in the case of LastWriterWins mode.
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
   * The procedure to resolve conflicts in the case of custom mode.
   *
   * @param {object} createUpdateGremlinGraphParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GremlinGraph} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GremlinGraph} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  createUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._createUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._createUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB Gremlin graph.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} graphName Cosmos DB graph name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  deleteGremlinGraphWithHttpOperationResponse(resourceGroupName, accountName, databaseName, graphName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._deleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB Gremlin graph.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} graphName Cosmos DB graph name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._deleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._deleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, optionalCallback);
    }
  }

  /**
   * Patches the properties of an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} updateParameters The tags parameter to patch for the current
   * database account.
   *
   * @param {object} [updateParameters.tags]
   *
   * @param {array} [updateParameters.capabilities] List of Cosmos DB
   * capabilities for the account
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DatabaseAccount>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginPatchWithHttpOperationResponse(resourceGroupName, accountName, updateParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginPatch(resourceGroupName, accountName, updateParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Patches the properties of an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} updateParameters The tags parameter to patch for the current
   * database account.
   *
   * @param {object} [updateParameters.tags]
   *
   * @param {array} [updateParameters.capabilities] List of Cosmos DB
   * capabilities for the account
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DatabaseAccount} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DatabaseAccount} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginPatch(resourceGroupName, accountName, updateParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginPatch(resourceGroupName, accountName, updateParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginPatch(resourceGroupName, accountName, updateParameters, options, optionalCallback);
    }
  }

  /**
   * Creates or updates an Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} createUpdateParameters The parameters to provide for the
   * current database account.
   *
   * @param {string} [createUpdateParameters.kind] Indicates the type of database
   * account. This can only be set at database account creation. Possible values
   * include: 'GlobalDocumentDB', 'MongoDB', 'Parse'
   *
   * @param {object} [createUpdateParameters.consistencyPolicy] The consistency
   * policy for the Cosmos DB account.
   *
   * @param {string}
   * createUpdateParameters.consistencyPolicy.defaultConsistencyLevel The default
   * consistency level and configuration settings of the Cosmos DB account.
   * Possible values include: 'Eventual', 'Session', 'BoundedStaleness',
   * 'Strong', 'ConsistentPrefix'
   *
   * @param {number}
   * [createUpdateParameters.consistencyPolicy.maxStalenessPrefix] When used with
   * the Bounded Staleness consistency level, this value represents the number of
   * stale requests tolerated. Accepted range for this value is 1 –
   * 2,147,483,647. Required when defaultConsistencyPolicy is set to
   * 'BoundedStaleness'.
   *
   * @param {number}
   * [createUpdateParameters.consistencyPolicy.maxIntervalInSeconds] When used
   * with the Bounded Staleness consistency level, this value represents the time
   * amount of staleness (in seconds) tolerated. Accepted range for this value is
   * 5 - 86400. Required when defaultConsistencyPolicy is set to
   * 'BoundedStaleness'.
   *
   * @param {array} createUpdateParameters.locations An array that contains the
   * georeplication locations enabled for the Cosmos DB account.
   *
   * @param {string} [createUpdateParameters.ipRangeFilter] Cosmos DB Firewall
   * Support: This value specifies the set of IP addresses or IP address ranges
   * in CIDR form to be included as the allowed list of client IPs for a given
   * database account. IP addresses/ranges must be comma separated and must not
   * contain any spaces.
   *
   * @param {boolean} [createUpdateParameters.isVirtualNetworkFilterEnabled] Flag
   * to indicate whether to enable/disable Virtual Network ACL rules.
   *
   * @param {boolean} [createUpdateParameters.enableAutomaticFailover] Enables
   * automatic failover of the write region in the rare event that the region is
   * unavailable due to an outage. Automatic failover will result in a new write
   * region for the account and is chosen based on the failover priorities
   * configured for the account.
   *
   * @param {array} [createUpdateParameters.capabilities] List of Cosmos DB
   * capabilities for the account
   *
   * @param {array} [createUpdateParameters.virtualNetworkRules] List of Virtual
   * Network ACL rules configured for the Cosmos DB account.
   *
   * @param {boolean} [createUpdateParameters.enableMultipleWriteLocations]
   * Enables the account to write in multiple locations
   *
   * @param {string} [createUpdateParameters.location] The location of the
   * resource group to which the resource belongs.
   *
   * @param {object} [createUpdateParameters.tags]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<DatabaseAccount>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateOrUpdateWithHttpOperationResponse(resourceGroupName, accountName, createUpdateParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateOrUpdate(resourceGroupName, accountName, createUpdateParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Creates or updates an Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} createUpdateParameters The parameters to provide for the
   * current database account.
   *
   * @param {string} [createUpdateParameters.kind] Indicates the type of database
   * account. This can only be set at database account creation. Possible values
   * include: 'GlobalDocumentDB', 'MongoDB', 'Parse'
   *
   * @param {object} [createUpdateParameters.consistencyPolicy] The consistency
   * policy for the Cosmos DB account.
   *
   * @param {string}
   * createUpdateParameters.consistencyPolicy.defaultConsistencyLevel The default
   * consistency level and configuration settings of the Cosmos DB account.
   * Possible values include: 'Eventual', 'Session', 'BoundedStaleness',
   * 'Strong', 'ConsistentPrefix'
   *
   * @param {number}
   * [createUpdateParameters.consistencyPolicy.maxStalenessPrefix] When used with
   * the Bounded Staleness consistency level, this value represents the number of
   * stale requests tolerated. Accepted range for this value is 1 –
   * 2,147,483,647. Required when defaultConsistencyPolicy is set to
   * 'BoundedStaleness'.
   *
   * @param {number}
   * [createUpdateParameters.consistencyPolicy.maxIntervalInSeconds] When used
   * with the Bounded Staleness consistency level, this value represents the time
   * amount of staleness (in seconds) tolerated. Accepted range for this value is
   * 5 - 86400. Required when defaultConsistencyPolicy is set to
   * 'BoundedStaleness'.
   *
   * @param {array} createUpdateParameters.locations An array that contains the
   * georeplication locations enabled for the Cosmos DB account.
   *
   * @param {string} [createUpdateParameters.ipRangeFilter] Cosmos DB Firewall
   * Support: This value specifies the set of IP addresses or IP address ranges
   * in CIDR form to be included as the allowed list of client IPs for a given
   * database account. IP addresses/ranges must be comma separated and must not
   * contain any spaces.
   *
   * @param {boolean} [createUpdateParameters.isVirtualNetworkFilterEnabled] Flag
   * to indicate whether to enable/disable Virtual Network ACL rules.
   *
   * @param {boolean} [createUpdateParameters.enableAutomaticFailover] Enables
   * automatic failover of the write region in the rare event that the region is
   * unavailable due to an outage. Automatic failover will result in a new write
   * region for the account and is chosen based on the failover priorities
   * configured for the account.
   *
   * @param {array} [createUpdateParameters.capabilities] List of Cosmos DB
   * capabilities for the account
   *
   * @param {array} [createUpdateParameters.virtualNetworkRules] List of Virtual
   * Network ACL rules configured for the Cosmos DB account.
   *
   * @param {boolean} [createUpdateParameters.enableMultipleWriteLocations]
   * Enables the account to write in multiple locations
   *
   * @param {string} [createUpdateParameters.location] The location of the
   * resource group to which the resource belongs.
   *
   * @param {object} [createUpdateParameters.tags]
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {DatabaseAccount} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link DatabaseAccount} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateOrUpdate(resourceGroupName, accountName, createUpdateParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateOrUpdate(resourceGroupName, accountName, createUpdateParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateOrUpdate(resourceGroupName, accountName, createUpdateParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginDeleteMethodWithHttpOperationResponse(resourceGroupName, accountName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginDeleteMethod(resourceGroupName, accountName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB database account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginDeleteMethod(resourceGroupName, accountName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginDeleteMethod(resourceGroupName, accountName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginDeleteMethod(resourceGroupName, accountName, options, optionalCallback);
    }
  }

  /**
   * Changes the failover priority for the Azure Cosmos DB database account. A
   * failover priority of 0 indicates a write region. The maximum value for a
   * failover priority = (total number of regions - 1). Failover priority values
   * must be unique for each of the regions in which the database account exists.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} failoverParameters The new failover policies for the
   * database account.
   *
   * @param {array} failoverParameters.failoverPolicies List of failover
   * policies.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginFailoverPriorityChangeWithHttpOperationResponse(resourceGroupName, accountName, failoverParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginFailoverPriorityChange(resourceGroupName, accountName, failoverParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Changes the failover priority for the Azure Cosmos DB database account. A
   * failover priority of 0 indicates a write region. The maximum value for a
   * failover priority = (total number of regions - 1). Failover priority values
   * must be unique for each of the regions in which the database account exists.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} failoverParameters The new failover policies for the
   * database account.
   *
   * @param {array} failoverParameters.failoverPolicies List of failover
   * policies.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginFailoverPriorityChange(resourceGroupName, accountName, failoverParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginFailoverPriorityChange(resourceGroupName, accountName, failoverParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginFailoverPriorityChange(resourceGroupName, accountName, failoverParameters, options, optionalCallback);
    }
  }

  /**
   * Offline the specified region for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} regionParameterForOffline Cosmos DB region to offline for
   * the database account.
   *
   * @param {string} regionParameterForOffline.region Cosmos DB region, with
   * spaces between words and each word capitalized.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginOfflineRegionWithHttpOperationResponse(resourceGroupName, accountName, regionParameterForOffline, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginOfflineRegion(resourceGroupName, accountName, regionParameterForOffline, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Offline the specified region for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} regionParameterForOffline Cosmos DB region to offline for
   * the database account.
   *
   * @param {string} regionParameterForOffline.region Cosmos DB region, with
   * spaces between words and each word capitalized.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginOfflineRegion(resourceGroupName, accountName, regionParameterForOffline, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginOfflineRegion(resourceGroupName, accountName, regionParameterForOffline, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginOfflineRegion(resourceGroupName, accountName, regionParameterForOffline, options, optionalCallback);
    }
  }

  /**
   * Online the specified region for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} regionParameterForOnline Cosmos DB region to online for the
   * database account.
   *
   * @param {string} regionParameterForOnline.region Cosmos DB region, with
   * spaces between words and each word capitalized.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginOnlineRegionWithHttpOperationResponse(resourceGroupName, accountName, regionParameterForOnline, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginOnlineRegion(resourceGroupName, accountName, regionParameterForOnline, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Online the specified region for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} regionParameterForOnline Cosmos DB region to online for the
   * database account.
   *
   * @param {string} regionParameterForOnline.region Cosmos DB region, with
   * spaces between words and each word capitalized.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginOnlineRegion(resourceGroupName, accountName, regionParameterForOnline, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginOnlineRegion(resourceGroupName, accountName, regionParameterForOnline, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginOnlineRegion(resourceGroupName, accountName, regionParameterForOnline, options, optionalCallback);
    }
  }

  /**
   * Regenerates an access key for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} keyToRegenerate The name of the key to regenerate.
   *
   * @param {string} keyToRegenerate.keyKind The access key to regenerate.
   * Possible values include: 'primary', 'secondary', 'primaryReadonly',
   * 'secondaryReadonly'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginRegenerateKeyWithHttpOperationResponse(resourceGroupName, accountName, keyToRegenerate, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginRegenerateKey(resourceGroupName, accountName, keyToRegenerate, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Regenerates an access key for the specified Azure Cosmos DB database
   * account.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {object} keyToRegenerate The name of the key to regenerate.
   *
   * @param {string} keyToRegenerate.keyKind The access key to regenerate.
   * Possible values include: 'primary', 'secondary', 'primaryReadonly',
   * 'secondaryReadonly'
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginRegenerateKey(resourceGroupName, accountName, keyToRegenerate, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginRegenerateKey(resourceGroupName, accountName, keyToRegenerate, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginRegenerateKey(resourceGroupName, accountName, keyToRegenerate, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB SQL database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateSqlDatabaseParameters The parameters to provide
   * for the current SQL database.
   *
   * @param {object} createUpdateSqlDatabaseParameters.resource The standard JSON
   * format of a SQL database
   *
   * @param {string} createUpdateSqlDatabaseParameters.resource.id Name of the
   * Cosmos DB SQL database
   *
   * @param {object} createUpdateSqlDatabaseParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SqlDatabase>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateUpdateSqlDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB SQL database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateSqlDatabaseParameters The parameters to provide
   * for the current SQL database.
   *
   * @param {object} createUpdateSqlDatabaseParameters.resource The standard JSON
   * format of a SQL database
   *
   * @param {string} createUpdateSqlDatabaseParameters.resource.id Name of the
   * Cosmos DB SQL database
   *
   * @param {object} createUpdateSqlDatabaseParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SqlDatabase} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SqlDatabase} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateUpdateSqlDatabase(resourceGroupName, accountName, databaseName, createUpdateSqlDatabaseParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginDeleteSqlDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginDeleteSqlDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginDeleteSqlDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginDeleteSqlDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginDeleteSqlDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB SQL container
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} containerName Cosmos DB container name.
   *
   * @param {object} createUpdateSqlContainerParameters The parameters to provide
   * for the current SQL container.
   *
   * @param {object} createUpdateSqlContainerParameters.resource The standard
   * JSON format of a container
   *
   * @param {string} createUpdateSqlContainerParameters.resource.id Name of the
   * Cosmos DB SQL container
   *
   * @param {object} [createUpdateSqlContainerParameters.resource.indexingPolicy]
   * The configuration of the indexing policy. By default, the indexing is
   * automatic for all document paths within the container
   *
   * @param {boolean}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.automatic]
   * Indicates if the indexing policy is automatic
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.indexingMode]
   * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
   * 'None'
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.includedPaths]
   * List of paths to include in the indexing
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.excludedPaths]
   * List of paths to exclude from indexing
   *
   * @param {object} [createUpdateSqlContainerParameters.resource.partitionKey]
   * The configuration of the partition key to be used for partitioning data into
   * multiple partitions
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.partitionKey.paths] List of
   * paths using which data within the container can be partitioned
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.partitionKey.kind] Indicates
   * the kind of algorithm used for partitioning. Possible values include:
   * 'Hash', 'Range'
   *
   * @param {number} [createUpdateSqlContainerParameters.resource.defaultTtl]
   * Default time to live
   *
   * @param {object}
   * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy] The unique key
   * policy configuration for specifying uniqueness constraints on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy.uniqueKeys]
   * List of unique keys on that enforces uniqueness constraint on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {object}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy] The
   * conflict resolution policy for the container.
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.mode]
   * Indicates the conflict resolution mode. Possible values include:
   * 'LastWriterWins', 'Custom'
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
   * The conflict resolution path in the case of LastWriterWins mode.
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
   * The procedure to resolve conflicts in the case of custom mode.
   *
   * @param {object} createUpdateSqlContainerParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<SqlContainer>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateUpdateSqlContainerWithHttpOperationResponse(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB SQL container
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} containerName Cosmos DB container name.
   *
   * @param {object} createUpdateSqlContainerParameters The parameters to provide
   * for the current SQL container.
   *
   * @param {object} createUpdateSqlContainerParameters.resource The standard
   * JSON format of a container
   *
   * @param {string} createUpdateSqlContainerParameters.resource.id Name of the
   * Cosmos DB SQL container
   *
   * @param {object} [createUpdateSqlContainerParameters.resource.indexingPolicy]
   * The configuration of the indexing policy. By default, the indexing is
   * automatic for all document paths within the container
   *
   * @param {boolean}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.automatic]
   * Indicates if the indexing policy is automatic
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.indexingMode]
   * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
   * 'None'
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.includedPaths]
   * List of paths to include in the indexing
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.indexingPolicy.excludedPaths]
   * List of paths to exclude from indexing
   *
   * @param {object} [createUpdateSqlContainerParameters.resource.partitionKey]
   * The configuration of the partition key to be used for partitioning data into
   * multiple partitions
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.partitionKey.paths] List of
   * paths using which data within the container can be partitioned
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.partitionKey.kind] Indicates
   * the kind of algorithm used for partitioning. Possible values include:
   * 'Hash', 'Range'
   *
   * @param {number} [createUpdateSqlContainerParameters.resource.defaultTtl]
   * Default time to live
   *
   * @param {object}
   * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy] The unique key
   * policy configuration for specifying uniqueness constraints on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {array}
   * [createUpdateSqlContainerParameters.resource.uniqueKeyPolicy.uniqueKeys]
   * List of unique keys on that enforces uniqueness constraint on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {object}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy] The
   * conflict resolution policy for the container.
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.mode]
   * Indicates the conflict resolution mode. Possible values include:
   * 'LastWriterWins', 'Custom'
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
   * The conflict resolution path in the case of LastWriterWins mode.
   *
   * @param {string}
   * [createUpdateSqlContainerParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
   * The procedure to resolve conflicts in the case of custom mode.
   *
   * @param {object} createUpdateSqlContainerParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {SqlContainer} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link SqlContainer} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateUpdateSqlContainer(resourceGroupName, accountName, databaseName, containerName, createUpdateSqlContainerParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL container.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} containerName Cosmos DB container name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginDeleteSqlContainerWithHttpOperationResponse(resourceGroupName, accountName, databaseName, containerName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginDeleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB SQL container.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} containerName Cosmos DB container name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginDeleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginDeleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginDeleteSqlContainer(resourceGroupName, accountName, databaseName, containerName, options, optionalCallback);
    }
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateMongoDBDatabaseParameters The parameters to
   * provide for the current MongoDB database.
   *
   * @param {object} createUpdateMongoDBDatabaseParameters.resource The standard
   * JSON format of a MongoDB database
   *
   * @param {string} createUpdateMongoDBDatabaseParameters.resource.id Name of
   * the Cosmos DB MongoDB database
   *
   * @param {object} createUpdateMongoDBDatabaseParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MongoDBDatabase>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateUpdateMongoDBDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or updates Azure Cosmos DB MongoDB database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateMongoDBDatabaseParameters The parameters to
   * provide for the current MongoDB database.
   *
   * @param {object} createUpdateMongoDBDatabaseParameters.resource The standard
   * JSON format of a MongoDB database
   *
   * @param {string} createUpdateMongoDBDatabaseParameters.resource.id Name of
   * the Cosmos DB MongoDB database
   *
   * @param {object} createUpdateMongoDBDatabaseParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MongoDBDatabase} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MongoDBDatabase} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateUpdateMongoDBDatabase(resourceGroupName, accountName, databaseName, createUpdateMongoDBDatabaseParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginDeleteMongoDBDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginDeleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginDeleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginDeleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginDeleteMongoDBDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} collectionName Cosmos DB collection name.
   *
   * @param {object} createUpdateMongoDBCollectionParameters The parameters to
   * provide for the current MongoDB Collection.
   *
   * @param {object} createUpdateMongoDBCollectionParameters.resource The
   * standard JSON format of a MongoDB collection
   *
   * @param {string} createUpdateMongoDBCollectionParameters.resource.id Name of
   * the Cosmos DB MongoDB collection
   *
   * @param {object} [createUpdateMongoDBCollectionParameters.resource.shardKey]
   * A key-value pair of shard keys to be applied for the request.
   *
   * @param {array} [createUpdateMongoDBCollectionParameters.resource.indexes]
   * List of index keys
   *
   * @param {object} createUpdateMongoDBCollectionParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<MongoDBCollection>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateUpdateMongoDBCollectionWithHttpOperationResponse(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB MongoDB Collection
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} collectionName Cosmos DB collection name.
   *
   * @param {object} createUpdateMongoDBCollectionParameters The parameters to
   * provide for the current MongoDB Collection.
   *
   * @param {object} createUpdateMongoDBCollectionParameters.resource The
   * standard JSON format of a MongoDB collection
   *
   * @param {string} createUpdateMongoDBCollectionParameters.resource.id Name of
   * the Cosmos DB MongoDB collection
   *
   * @param {object} [createUpdateMongoDBCollectionParameters.resource.shardKey]
   * A key-value pair of shard keys to be applied for the request.
   *
   * @param {array} [createUpdateMongoDBCollectionParameters.resource.indexes]
   * List of index keys
   *
   * @param {object} createUpdateMongoDBCollectionParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {MongoDBCollection} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link MongoDBCollection} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateUpdateMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, createUpdateMongoDBCollectionParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} collectionName Cosmos DB collection name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginDeleteMongoDBCollectionWithHttpOperationResponse(resourceGroupName, accountName, databaseName, collectionName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginDeleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB MongoDB Collection.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} collectionName Cosmos DB collection name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginDeleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginDeleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginDeleteMongoDBCollection(resourceGroupName, accountName, databaseName, collectionName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB Table
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} createUpdateTableParameters The parameters to provide for
   * the current Table.
   *
   * @param {object} createUpdateTableParameters.resource The standard JSON
   * format of a Table
   *
   * @param {string} createUpdateTableParameters.resource.id Name of the Cosmos
   * DB table
   *
   * @param {object} createUpdateTableParameters.options A key-value pair of
   * options to be applied for the request. This corresponds to the headers sent
   * with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<Table>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateUpdateTableWithHttpOperationResponse(resourceGroupName, accountName, tableName, createUpdateTableParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB Table
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} createUpdateTableParameters The parameters to provide for
   * the current Table.
   *
   * @param {object} createUpdateTableParameters.resource The standard JSON
   * format of a Table
   *
   * @param {string} createUpdateTableParameters.resource.id Name of the Cosmos
   * DB table
   *
   * @param {object} createUpdateTableParameters.options A key-value pair of
   * options to be applied for the request. This corresponds to the headers sent
   * with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {Table} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link Table} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateUpdateTable(resourceGroupName, accountName, tableName, createUpdateTableParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB Table.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginDeleteTableWithHttpOperationResponse(resourceGroupName, accountName, tableName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginDeleteTable(resourceGroupName, accountName, tableName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB Table.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginDeleteTable(resourceGroupName, accountName, tableName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginDeleteTable(resourceGroupName, accountName, tableName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginDeleteTable(resourceGroupName, accountName, tableName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB Cassandra keyspace
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} createUpdateCassandraKeyspaceParameters The parameters to
   * provide for the current Cassandra keyspace.
   *
   * @param {object} createUpdateCassandraKeyspaceParameters.resource The
   * standard JSON format of a Cassandra keyspace
   *
   * @param {string} createUpdateCassandraKeyspaceParameters.resource.id Name of
   * the Cosmos DB Cassandra keyspace
   *
   * @param {object} createUpdateCassandraKeyspaceParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CassandraKeyspace>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateUpdateCassandraKeyspaceWithHttpOperationResponse(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB Cassandra keyspace
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} createUpdateCassandraKeyspaceParameters The parameters to
   * provide for the current Cassandra keyspace.
   *
   * @param {object} createUpdateCassandraKeyspaceParameters.resource The
   * standard JSON format of a Cassandra keyspace
   *
   * @param {string} createUpdateCassandraKeyspaceParameters.resource.id Name of
   * the Cosmos DB Cassandra keyspace
   *
   * @param {object} createUpdateCassandraKeyspaceParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CassandraKeyspace} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CassandraKeyspace} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateUpdateCassandraKeyspace(resourceGroupName, accountName, keyspaceName, createUpdateCassandraKeyspaceParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB Cassandra keyspace.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginDeleteCassandraKeyspaceWithHttpOperationResponse(resourceGroupName, accountName, keyspaceName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginDeleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB Cassandra keyspace.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginDeleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginDeleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginDeleteCassandraKeyspace(resourceGroupName, accountName, keyspaceName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB Cassandra Table
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} createUpdateCassandraTableParameters The parameters to
   * provide for the current Cassandra Table.
   *
   * @param {object} createUpdateCassandraTableParameters.resource The standard
   * JSON format of a Cassandra table
   *
   * @param {string} createUpdateCassandraTableParameters.resource.id Name of the
   * Cosmos DB Cassandra table
   *
   * @param {number} [createUpdateCassandraTableParameters.resource.defaultTtl]
   * Time to live of the Cosmos DB Cassandra table
   *
   * @param {object} [createUpdateCassandraTableParameters.resource.schema]
   * Schema of the Cosmos DB Cassandra table
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.columns] List of
   * Cassandra table columns.
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.partitionKeys] List of
   * partition key.
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.clusterKeys] List of
   * cluster key.
   *
   * @param {object} createUpdateCassandraTableParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<CassandraTable>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateUpdateCassandraTableWithHttpOperationResponse(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB Cassandra Table
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} createUpdateCassandraTableParameters The parameters to
   * provide for the current Cassandra Table.
   *
   * @param {object} createUpdateCassandraTableParameters.resource The standard
   * JSON format of a Cassandra table
   *
   * @param {string} createUpdateCassandraTableParameters.resource.id Name of the
   * Cosmos DB Cassandra table
   *
   * @param {number} [createUpdateCassandraTableParameters.resource.defaultTtl]
   * Time to live of the Cosmos DB Cassandra table
   *
   * @param {object} [createUpdateCassandraTableParameters.resource.schema]
   * Schema of the Cosmos DB Cassandra table
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.columns] List of
   * Cassandra table columns.
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.partitionKeys] List of
   * partition key.
   *
   * @param {array}
   * [createUpdateCassandraTableParameters.resource.schema.clusterKeys] List of
   * cluster key.
   *
   * @param {object} createUpdateCassandraTableParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {CassandraTable} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link CassandraTable} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateUpdateCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, createUpdateCassandraTableParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB Cassandra table.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginDeleteCassandraTableWithHttpOperationResponse(resourceGroupName, accountName, keyspaceName, tableName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginDeleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB Cassandra table.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} keyspaceName Cosmos DB keyspace name.
   *
   * @param {string} tableName Cosmos DB table name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginDeleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginDeleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginDeleteCassandraTable(resourceGroupName, accountName, keyspaceName, tableName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB Gremlin database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateGremlinDatabaseParameters The parameters to
   * provide for the current Gremlin database.
   *
   * @param {object} createUpdateGremlinDatabaseParameters.resource The standard
   * JSON format of a Gremlin database
   *
   * @param {string} createUpdateGremlinDatabaseParameters.resource.id Name of
   * the Cosmos DB Gremlin database
   *
   * @param {object} createUpdateGremlinDatabaseParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GremlinDatabase>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateUpdateGremlinDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB Gremlin database
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} createUpdateGremlinDatabaseParameters The parameters to
   * provide for the current Gremlin database.
   *
   * @param {object} createUpdateGremlinDatabaseParameters.resource The standard
   * JSON format of a Gremlin database
   *
   * @param {string} createUpdateGremlinDatabaseParameters.resource.id Name of
   * the Cosmos DB Gremlin database
   *
   * @param {object} createUpdateGremlinDatabaseParameters.options A key-value
   * pair of options to be applied for the request. This corresponds to the
   * headers sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GremlinDatabase} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GremlinDatabase} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateUpdateGremlinDatabase(resourceGroupName, accountName, databaseName, createUpdateGremlinDatabaseParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB Gremlin database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginDeleteGremlinDatabaseWithHttpOperationResponse(resourceGroupName, accountName, databaseName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginDeleteGremlinDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB Gremlin database.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginDeleteGremlinDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginDeleteGremlinDatabase(resourceGroupName, accountName, databaseName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginDeleteGremlinDatabase(resourceGroupName, accountName, databaseName, options, optionalCallback);
    }
  }

  /**
   * Create or update an Azure Cosmos DB Gremlin graph
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} graphName Cosmos DB graph name.
   *
   * @param {object} createUpdateGremlinGraphParameters The parameters to provide
   * for the current Gremlin graph.
   *
   * @param {object} createUpdateGremlinGraphParameters.resource The standard
   * JSON format of a Gremlin graph
   *
   * @param {string} createUpdateGremlinGraphParameters.resource.id Name of the
   * Cosmos DB Gremlin graph
   *
   * @param {object} [createUpdateGremlinGraphParameters.resource.indexingPolicy]
   * The configuration of the indexing policy. By default, the indexing is
   * automatic for all document paths within the graph
   *
   * @param {boolean}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.automatic]
   * Indicates if the indexing policy is automatic
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.indexingMode]
   * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
   * 'None'
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.includedPaths]
   * List of paths to include in the indexing
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.excludedPaths]
   * List of paths to exclude from indexing
   *
   * @param {object} [createUpdateGremlinGraphParameters.resource.partitionKey]
   * The configuration of the partition key to be used for partitioning data into
   * multiple partitions
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.partitionKey.paths] List of
   * paths using which data within the container can be partitioned
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.partitionKey.kind] Indicates
   * the kind of algorithm used for partitioning. Possible values include:
   * 'Hash', 'Range'
   *
   * @param {number} [createUpdateGremlinGraphParameters.resource.defaultTtl]
   * Default time to live
   *
   * @param {object}
   * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy] The unique key
   * policy configuration for specifying uniqueness constraints on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy.uniqueKeys]
   * List of unique keys on that enforces uniqueness constraint on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {object}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy] The
   * conflict resolution policy for the graph.
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.mode]
   * Indicates the conflict resolution mode. Possible values include:
   * 'LastWriterWins', 'Custom'
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
   * The conflict resolution path in the case of LastWriterWins mode.
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
   * The procedure to resolve conflicts in the case of custom mode.
   *
   * @param {object} createUpdateGremlinGraphParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<GremlinGraph>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginCreateUpdateGremlinGraphWithHttpOperationResponse(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginCreateUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Create or update an Azure Cosmos DB Gremlin graph
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} graphName Cosmos DB graph name.
   *
   * @param {object} createUpdateGremlinGraphParameters The parameters to provide
   * for the current Gremlin graph.
   *
   * @param {object} createUpdateGremlinGraphParameters.resource The standard
   * JSON format of a Gremlin graph
   *
   * @param {string} createUpdateGremlinGraphParameters.resource.id Name of the
   * Cosmos DB Gremlin graph
   *
   * @param {object} [createUpdateGremlinGraphParameters.resource.indexingPolicy]
   * The configuration of the indexing policy. By default, the indexing is
   * automatic for all document paths within the graph
   *
   * @param {boolean}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.automatic]
   * Indicates if the indexing policy is automatic
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.indexingMode]
   * Indicates the indexing mode. Possible values include: 'Consistent', 'Lazy',
   * 'None'
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.includedPaths]
   * List of paths to include in the indexing
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.indexingPolicy.excludedPaths]
   * List of paths to exclude from indexing
   *
   * @param {object} [createUpdateGremlinGraphParameters.resource.partitionKey]
   * The configuration of the partition key to be used for partitioning data into
   * multiple partitions
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.partitionKey.paths] List of
   * paths using which data within the container can be partitioned
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.partitionKey.kind] Indicates
   * the kind of algorithm used for partitioning. Possible values include:
   * 'Hash', 'Range'
   *
   * @param {number} [createUpdateGremlinGraphParameters.resource.defaultTtl]
   * Default time to live
   *
   * @param {object}
   * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy] The unique key
   * policy configuration for specifying uniqueness constraints on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {array}
   * [createUpdateGremlinGraphParameters.resource.uniqueKeyPolicy.uniqueKeys]
   * List of unique keys on that enforces uniqueness constraint on documents in
   * the collection in the Azure Cosmos DB service.
   *
   * @param {object}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy] The
   * conflict resolution policy for the graph.
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.mode]
   * Indicates the conflict resolution mode. Possible values include:
   * 'LastWriterWins', 'Custom'
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionPath]
   * The conflict resolution path in the case of LastWriterWins mode.
   *
   * @param {string}
   * [createUpdateGremlinGraphParameters.resource.conflictResolutionPolicy.conflictResolutionProcedure]
   * The procedure to resolve conflicts in the case of custom mode.
   *
   * @param {object} createUpdateGremlinGraphParameters.options A key-value pair
   * of options to be applied for the request. This corresponds to the headers
   * sent with the request.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {GremlinGraph} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {object} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link GremlinGraph} for more information.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginCreateUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginCreateUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginCreateUpdateGremlinGraph(resourceGroupName, accountName, databaseName, graphName, createUpdateGremlinGraphParameters, options, optionalCallback);
    }
  }

  /**
   * Deletes an existing Azure Cosmos DB Gremlin graph.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} graphName Cosmos DB graph name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error} - The error object.
   */
  beginDeleteGremlinGraphWithHttpOperationResponse(resourceGroupName, accountName, databaseName, graphName, options) {
    let client = this.client;
    let self = this;
    return new Promise((resolve, reject) => {
      self._beginDeleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, (err, result, request, response) => {
        let httpOperationResponse = new msRest.HttpOperationResponse(request, response);
        httpOperationResponse.body = result;
        if (err) { reject(err); }
        else { resolve(httpOperationResponse); }
        return;
      });
    });
  }

  /**
   * Deletes an existing Azure Cosmos DB Gremlin graph.
   *
   * @param {string} resourceGroupName Name of an Azure resource group.
   *
   * @param {string} accountName Cosmos DB database account name.
   *
   * @param {string} databaseName Cosmos DB database name.
   *
   * @param {string} graphName Cosmos DB graph name.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {function} [optionalCallback] - The optional callback.
   *
   * @returns {function|Promise} If a callback was passed as the last parameter
   * then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error} - The error object.
   *
   * {function} optionalCallback(err, result, request, response)
   *
   *                      {Error}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {object} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {stream} [response] - The HTTP Response stream if an error did not occur.
   */
  beginDeleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, optionalCallback) {
    let client = this.client;
    let self = this;
    if (!optionalCallback && typeof options === 'function') {
      optionalCallback = options;
      options = null;
    }
    if (!optionalCallback) {
      return new Promise((resolve, reject) => {
        self._beginDeleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, (err, result, request, response) => {
          if (err) { reject(err); }
          else { resolve(result); }
          return;
        });
      });
    } else {
      return self._beginDeleteGremlinGraph(resourceGroupName, accountName, databaseName, graphName, options, optionalCallback);
    }
  }

}

module.exports = DatabaseAccounts;
