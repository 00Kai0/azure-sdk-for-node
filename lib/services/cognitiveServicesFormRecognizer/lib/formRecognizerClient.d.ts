/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

import { ServiceClient, ServiceClientOptions, ServiceCallback, HttpOperationResponse, ServiceClientCredentials } from 'ms-rest';
import * as models from "./models";

export default class FormRecognizerClient extends ServiceClient {
  /**
   * @class
   * Initializes a new instance of the FormRecognizerClient class.
   * @constructor
   *
   * @param {credentials} credentials - Subscription credentials which uniquely identify client subscription.
   *
   * @param {string} endpoint - Supported Cognitive Services endpoints (protocol and hostname, for example: https://westus2.api.cognitive.microsoft.com).
   *
   * @param {object} [options] - The parameter options
   *
   * @param {Array} [options.filters] - Filters to be added to the request pipeline
   *
   * @param {object} [options.requestOptions] - Options for the underlying request object
   * {@link https://github.com/request/request#requestoptions-callback Options doc}
   *
   * @param {boolean} [options.noRetryPolicy] - If set to true, turn off default retry policy
   *
   */
  constructor(credentials: ServiceClientCredentials, endpoint: string, options?: ServiceClientOptions);

  credentials: ServiceClientCredentials;

  endpoint: string;


  /**
   * @summary Train Model
   *
   * Create and train a custom model. The train request must include a source
   * parameter that is either an externally accessible Azure Storage blob
   * container Uri (preferably a Shared Access Signature Uri) or valid path to a
   * data folder in a locally mounted drive. When local paths are specified, they
   * must follow the Linux/Unix path format and be an absolute path rooted to the
   * input mount configuration
   * setting value e.g., if '{Mounts:Input}' configuration setting value is
   * '/input' then a valid source path would be '/input/contosodataset'. All data
   * to be trained is expected to be directly under the source folder. Subfolders
   * are not supported. Models are trained using documents that are of the
   * following content type - 'application/pdf', 'image/jpeg' and 'image/png'."
   * Other type of content is ignored.
   *
   * @param {object} trainRequest Request object for training.
   *
   * @param {string} trainRequest.source Get or set source path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<TrainResult>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  trainCustomModelWithHttpOperationResponse(trainRequest: models.TrainRequest, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.TrainResult>>;

  /**
   * @summary Train Model
   *
   * Create and train a custom model. The train request must include a source
   * parameter that is either an externally accessible Azure Storage blob
   * container Uri (preferably a Shared Access Signature Uri) or valid path to a
   * data folder in a locally mounted drive. When local paths are specified, they
   * must follow the Linux/Unix path format and be an absolute path rooted to the
   * input mount configuration
   * setting value e.g., if '{Mounts:Input}' configuration setting value is
   * '/input' then a valid source path would be '/input/contosodataset'. All data
   * to be trained is expected to be directly under the source folder. Subfolders
   * are not supported. Models are trained using documents that are of the
   * following content type - 'application/pdf', 'image/jpeg' and 'image/png'."
   * Other type of content is ignored.
   *
   * @param {object} trainRequest Request object for training.
   *
   * @param {string} trainRequest.source Get or set source path.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {TrainResult} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {TrainResult} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link TrainResult} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  trainCustomModel(trainRequest: models.TrainRequest, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.TrainResult>;
  trainCustomModel(trainRequest: models.TrainRequest, callback: ServiceCallback<models.TrainResult>): void;
  trainCustomModel(trainRequest: models.TrainRequest, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.TrainResult>): void;


  /**
   * @summary Get Keys
   *
   * Retrieve the keys that were
   * extracted during the training of the specified model.
   *
   * @param {uuid} id Model identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<KeysResult>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getExtractedKeysWithHttpOperationResponse(id: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.KeysResult>>;

  /**
   * @summary Get Keys
   *
   * Retrieve the keys that were
   * extracted during the training of the specified model.
   *
   * @param {uuid} id Model identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {KeysResult} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {KeysResult} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link KeysResult} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getExtractedKeys(id: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.KeysResult>;
  getExtractedKeys(id: string, callback: ServiceCallback<models.KeysResult>): void;
  getExtractedKeys(id: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.KeysResult>): void;


  /**
   * @summary Get Models
   *
   * Get information about all trained custom models
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ModelsResult>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getCustomModelsWithHttpOperationResponse(options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ModelsResult>>;

  /**
   * @summary Get Models
   *
   * Get information about all trained custom models
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ModelsResult} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ModelsResult} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ModelsResult} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getCustomModels(options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ModelsResult>;
  getCustomModels(callback: ServiceCallback<models.ModelsResult>): void;
  getCustomModels(options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ModelsResult>): void;


  /**
   * @summary Get Model
   *
   * Get information about a model.
   *
   * @param {uuid} id Model identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ModelResult>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getCustomModelWithHttpOperationResponse(id: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ModelResult>>;

  /**
   * @summary Get Model
   *
   * Get information about a model.
   *
   * @param {uuid} id Model identifier.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ModelResult} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ModelResult} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ModelResult} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getCustomModel(id: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ModelResult>;
  getCustomModel(id: string, callback: ServiceCallback<models.ModelResult>): void;
  getCustomModel(id: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ModelResult>): void;


  /**
   * @summary Delete Model
   *
   * Delete model artifacts.
   *
   * @param {uuid} id The identifier of the model to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  deleteCustomModelWithHttpOperationResponse(id: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * @summary Delete Model
   *
   * Delete model artifacts.
   *
   * @param {uuid} id The identifier of the model to delete.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  deleteCustomModel(id: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  deleteCustomModel(id: string, callback: ServiceCallback<void>): void;
  deleteCustomModel(id: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * @summary Analyze Form
   *
   * Extract key-value pairs from a given document. The input document must be of
   * one of the supported content types - 'application/pdf', 'image/jpeg' or
   * 'image/png'. A success response is returned in JSON.
   *
   * @param {uuid} id Model Identifier to analyze the document with.
   *
   * @param {object} formStream A pdf document or image (jpg,png) file to
   * analyze.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {array} [options.keys] An optional list of known keys to extract the
   * values for.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<AnalyzeResult>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  analyzeWithCustomModelWithHttpOperationResponse(id: string, formStream: stream.Readable, options?: { keys? : string[], customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.AnalyzeResult>>;

  /**
   * @summary Analyze Form
   *
   * Extract key-value pairs from a given document. The input document must be of
   * one of the supported content types - 'application/pdf', 'image/jpeg' or
   * 'image/png'. A success response is returned in JSON.
   *
   * @param {uuid} id Model Identifier to analyze the document with.
   *
   * @param {object} formStream A pdf document or image (jpg,png) file to
   * analyze.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {array} [options.keys] An optional list of known keys to extract the
   * values for.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {AnalyzeResult} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {AnalyzeResult} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link AnalyzeResult} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  analyzeWithCustomModel(id: string, formStream: stream.Readable, options?: { keys? : string[], customHeaders? : { [headerName: string]: string; } }): Promise<models.AnalyzeResult>;
  analyzeWithCustomModel(id: string, formStream: stream.Readable, callback: ServiceCallback<models.AnalyzeResult>): void;
  analyzeWithCustomModel(id: string, formStream: stream.Readable, options: { keys? : string[], customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.AnalyzeResult>): void;


  /**
   * Batch Read Receipt operation. The response contains a field called
   * 'Operation-Location', which contains the URL that you must use for your 'Get
   * Read Receipt Result' operation.
   *
   * @param {string} url Publicly reachable URL of an image.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  batchReadReceiptWithHttpOperationResponse(url: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * Batch Read Receipt operation. The response contains a field called
   * 'Operation-Location', which contains the URL that you must use for your 'Get
   * Read Receipt Result' operation.
   *
   * @param {string} url Publicly reachable URL of an image.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  batchReadReceipt(url: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  batchReadReceipt(url: string, callback: ServiceCallback<void>): void;
  batchReadReceipt(url: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;


  /**
   * This interface is used for getting the analysis results of a 'Batch Read
   * Receipt' operation. The URL to this interface should be retrieved from the
   * 'Operation-Location' field returned from the 'Batch Read Receipt' operation.
   *
   * @param {string} operationId Id of read operation returned in the response of
   * a 'Batch Read Receipt' operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<ReadReceiptResult>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  getReadReceiptResultWithHttpOperationResponse(operationId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<models.ReadReceiptResult>>;

  /**
   * This interface is used for getting the analysis results of a 'Batch Read
   * Receipt' operation. The URL to this interface should be retrieved from the
   * 'Operation-Location' field returned from the 'Batch Read Receipt' operation.
   *
   * @param {string} operationId Id of read operation returned in the response of
   * a 'Batch Read Receipt' operation.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {ReadReceiptResult} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {ReadReceiptResult} [result]   - The deserialized result object if an error did not occur.
   *                      See {@link ReadReceiptResult} for more information.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  getReadReceiptResult(operationId: string, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<models.ReadReceiptResult>;
  getReadReceiptResult(operationId: string, callback: ServiceCallback<models.ReadReceiptResult>): void;
  getReadReceiptResult(operationId: string, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<models.ReadReceiptResult>): void;


  /**
   * Read Receipt operation. When you use the 'Batch Read Receipt' interface, the
   * response contains a field called 'Operation-Location'. The
   * 'Operation-Location' field contains the URL that you must use for your 'Get
   * Read Receipt Result' operation.
   *
   * @param {object} image An image stream.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @returns {Promise} A promise is returned
   *
   * @resolve {HttpOperationResponse<null>} - The deserialized result object.
   *
   * @reject {Error|ServiceError} - The error object.
   */
  batchReadReceiptInStreamWithHttpOperationResponse(image: stream.Readable, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<HttpOperationResponse<void>>;

  /**
   * Read Receipt operation. When you use the 'Batch Read Receipt' interface, the
   * response contains a field called 'Operation-Location'. The
   * 'Operation-Location' field contains the URL that you must use for your 'Get
   * Read Receipt Result' operation.
   *
   * @param {object} image An image stream.
   *
   * @param {object} [options] Optional Parameters.
   *
   * @param {object} [options.customHeaders] Headers that will be added to the
   * request
   *
   * @param {ServiceCallback} [optionalCallback] - The optional callback.
   *
   * @returns {ServiceCallback|Promise} If a callback was passed as the last
   * parameter then it returns the callback else returns a Promise.
   *
   * {Promise} A promise is returned.
   *
   *                      @resolve {null} - The deserialized result object.
   *
   *                      @reject {Error|ServiceError} - The error object.
   *
   * {ServiceCallback} optionalCallback(err, result, request, response)
   *
   *                      {Error|ServiceError}  err        - The Error object if an error occurred, null otherwise.
   *
   *                      {null} [result]   - The deserialized result object if an error did not occur.
   *
   *                      {WebResource} [request]  - The HTTP Request object if an error did not occur.
   *
   *                      {http.IncomingMessage} [response] - The HTTP Response stream if an error did not occur.
   */
  batchReadReceiptInStream(image: stream.Readable, options?: { customHeaders? : { [headerName: string]: string; } }): Promise<void>;
  batchReadReceiptInStream(image: stream.Readable, callback: ServiceCallback<void>): void;
  batchReadReceiptInStream(image: stream.Readable, options: { customHeaders? : { [headerName: string]: string; } }, callback: ServiceCallback<void>): void;
}

export { FormRecognizerClient, models as FormRecognizerModels };
