/*
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for
 * license information.
 * 
 * Code generated by Microsoft (R) AutoRest Code Generator 0.14.0.0
 * Changes may cause incorrect behavior and will be lost if the code is
 * regenerated.
 */

'use strict';

var util = require('util');
var msRest = require('ms-rest');
var msRestAzure = require('ms-rest-azure');
var WebResource = msRest.WebResource;

/**
 * @class
 * FileSystem
 * __NOTE__: An instance of this class is automatically created for an
 * instance of the DataLakeStoreFileSystemManagementClient.
 * Initializes a new instance of the FileSystem class.
 * @constructor
 *
 * @param {DataLakeStoreFileSystemManagementClient} client Reference to the service client.
 */
function FileSystem(client) {
  this.client = client;
}

/**
 * Get the file information object used to check file expiration time for the
 * specified by the file path.
 *
 * @param {string} filePath The path to the file to retrieve expiration
 * information for.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link FileInfoResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.getFileInfo = function (filePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'GETFILEINFO';
  // Validate
  try {
    if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
      throw new Error('filePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//WebHdfsExt/{filePath}';
  requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['FileInfoResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Appends to the file specified. This method supports multiple concurrent
 * appends to the file. NOTE: that concurrent append and serial append CANNOT
 * be used interchangeably. Once a file has been appended to using either
 * one, it can only be appended to using that type of append.
 *
 * @param {string} filePath The path to the file to append to using concurrent
 * append.
 * 
 * @param {string} accountname The name of the data lake account that the file
 * lives in.
 * 
 * @param {object} streamContents The file contents to include when appending
 * to the file.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.appendMode] Indicates the concurrent append call
 * should create the file if it doesn't exist or just open the existing file
 * for append. Possible values for this parameter include: 'autocreate'
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.concurrentAppend = function (filePath, accountname, streamContents, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var appendMode = (options && options.appendMode !== undefined) ? options.appendMode : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'CONCURRENTAPPEND';
  // Validate
  try {
    if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
      throw new Error('filePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (streamContents === null || streamContents === undefined) {
      throw new Error('streamContents cannot be null or undefined and it must be of type object.');
    }
    if (appendMode) {
      var allowedValues = [ 'autocreate' ];
      if (!allowedValues.some( function(item) { return item === appendMode; })) {
        throw new Error(appendMode + ' is not a valid value. The valid values are: ' + allowedValues);
      }
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//WebHdfsExt/{filePath}';
  requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (appendMode !== null && appendMode !== undefined) {
    queryParameters.push('appendMode=' + encodeURIComponent(appendMode));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/octet-stream';
  // Serialize Request  
  var requestContent = streamContents;
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Sets or removes the expiration time on the specified file. This operation
 * can only be executed against files. Folders are not supported.
 *
 * @param {string} filePath The path to the file to set or removes the
 * expiration time on.
 * 
 * @param {string} accountname The name of the data lake account that the file
 * lives in.
 * 
 * @param {string} expiryOption Indicates the type of expiration to use for
 * the file: 1. NeverExpire: ExpireTime is ignored. 2. RelativeToNow:
 * ExpireTime is an integer in milliseconds. 3. RelativeToCreationDate:
 * ExpireTime is an integer in milliseconds. 4. Absolute: ExpireTime is an
 * integer in milliseconds, as a unix timestamp relative to 1/1/1970
 * 00:00:00. Possible values for this parameter include: 'NeverExpire',
 * 'RelativeToNow', 'RelativeToCreationDate', 'Absolute'
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {number} [options.expireTime] The time, in seconds, that the file
 * will expire relative to the expiry option that was set.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.setFileExpiry = function (filePath, accountname, expiryOption, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var expireTime = (options && options.expireTime !== undefined) ? options.expireTime : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'SETEXPIRY';
  // Validate
  try {
    if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
      throw new Error('filePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (expiryOption) {
      var allowedValues = [ 'NeverExpire', 'RelativeToNow', 'RelativeToCreationDate', 'Absolute' ];
      if (!allowedValues.some( function(item) { return item === expiryOption; })) {
        throw new Error(expiryOption + ' is not a valid value. The valid values are: ' + allowedValues);
      }
    } else {
      throw new Error('expiryOption cannot be null or undefined.');
    }
    if (expireTime !== null && expireTime !== undefined && typeof expireTime !== 'number') {
      throw new Error('expireTime must be of type number.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//WebHdfsExt/{filePath}';
  requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  queryParameters.push('expiryOption=' + encodeURIComponent(expiryOption));
  if (expireTime !== null && expireTime !== undefined) {
    queryParameters.push('expireTime=' + encodeURIComponent(expireTime.toString()));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Checks if the specified access is available at the given path.
 *
 * @param {string} path The path to the file or folder to check access for.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.fsaction] File system operation read/write/execute
 * in string form, matching regex pattern '[rwx-]{3}'
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.checkAccess = function (path, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var fsaction = (options && options.fsaction !== undefined) ? options.fsaction : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'CHECKACCESS';
  // Validate
  try {
    if (path === null || path === undefined || typeof path.valueOf() !== 'string') {
      throw new Error('path cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (fsaction !== null && fsaction !== undefined && typeof fsaction.valueOf() !== 'string') {
      throw new Error('fsaction must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{path}';
  requestUrl = requestUrl.replace('{path}', encodeURIComponent(path));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (fsaction !== null && fsaction !== undefined) {
    queryParameters.push('fsaction=' + encodeURIComponent(fsaction));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Creates a directory.
 *
 * @param {string} path The path to the directory to create.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.permission] The optional permissions to set on the
 * directories
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link FileOperationResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.mkdirs = function (path, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var permission = (options && options.permission !== undefined) ? options.permission : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'MKDIRS';
  // Validate
  try {
    if (path === null || path === undefined || typeof path.valueOf() !== 'string') {
      throw new Error('path cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (permission !== null && permission !== undefined && typeof permission.valueOf() !== 'string') {
      throw new Error('permission must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{path}';
  requestUrl = requestUrl.replace('{path}', encodeURIComponent(path));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (permission !== null && permission !== undefined) {
    queryParameters.push('permission=' + encodeURIComponent(permission));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['FileOperationResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Concatenates the list of files into the target file.
 *
 * @param {string} destinationPath The path to the destination file resulting
 * from the concatenation.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {array} sources A list of comma seperated absolute FileSystem paths
 * without scheme and authority
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.concat = function (destinationPath, accountname, sources, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'CONCAT';
  // Validate
  try {
    if (destinationPath === null || destinationPath === undefined || typeof destinationPath.valueOf() !== 'string') {
      throw new Error('destinationPath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (!util.isArray(sources)) {
      throw new Error('sources cannot be null or undefined and it must be of type array.');
    }
    for (var i = 0; i < sources.length; i++) {
      if (sources[i] !== null && sources[i] !== undefined && typeof sources[i].valueOf() !== 'string') {
        throw new Error('sources[i] must be of type string.');
      }
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{destinationPath}';
  requestUrl = requestUrl.replace('{destinationPath}', encodeURIComponent(destinationPath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  queryParameters.push('sources=' + encodeURIComponent(sources.join(',')));
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Concatenates the list of files into the target file. This API is NOT
 * webhdfs compliant, however supports a much larger list of files in the
 * concatenate list.
 *
 * @param {string} msConcatDestinationPath The path to the destination file
 * resulting from the concatenation.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} streamContents A list of comma seperated absolute
 * FileSystem paths without scheme and authority. In the format:
 * 'sources=<comma separated list>'
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {boolean} [options.deletesourcedirectory] Indicates two things to
 * the system which allow for optimizations and increased concatenate
 * performance. First, that all the streams being concatenated are in the
 * same source directory. Second, that the source directory ONLY has streams
 * in it that are being concatenated into the destination stream. Note that
 * only the first requirement is strictly enforced (concatenate will ignore
 * the flag and only delete the source streams, not the folder). If the first
 * option is met, ALL data that was not part of the set of streams being
 * concatenated WILL BE LOST. It is critical to only use this option if you
 * are certain the two requirements are met.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.msConcat = function (msConcatDestinationPath, accountname, streamContents, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var deletesourcedirectory = (options && options.deletesourcedirectory !== undefined) ? options.deletesourcedirectory : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'MSCONCAT';
  // Validate
  try {
    if (msConcatDestinationPath === null || msConcatDestinationPath === undefined || typeof msConcatDestinationPath.valueOf() !== 'string') {
      throw new Error('msConcatDestinationPath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (deletesourcedirectory !== null && deletesourcedirectory !== undefined && typeof deletesourcedirectory !== 'boolean') {
      throw new Error('deletesourcedirectory must be of type boolean.');
    }
    if (streamContents === null || streamContents === undefined) {
      throw new Error('streamContents cannot be null or undefined and it must be of type object.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{msConcatDestinationPath}';
  requestUrl = requestUrl.replace('{msConcatDestinationPath}', encodeURIComponent(msConcatDestinationPath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (deletesourcedirectory !== null && deletesourcedirectory !== undefined) {
    queryParameters.push('deletesourcedirectory=' + encodeURIComponent(deletesourcedirectory.toString()));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/octet-stream';
  // Serialize Request  
  var requestContent = streamContents;
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Get the list of file status objects specified by the file path, with
 * optional pagination parameters
 *
 * @param {string} listFilePath The path to the file to retrieve status for.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {number} [options.listSize] Gets or sets the number of items to
 * return. Optional.
 * 
 * @param {string} [options.listAfter] Gets or sets the item or lexographical
 * index to begin returning results after. For example, with a file list of
 * 'a','b','d' a listAfter='b' will return 'd' and a listAfter='c' will also
 * return 'd'. Optional.
 * 
 * @param {string} [options.listBefore] Gets or sets the item or lexographical
 * index to begin returning results before. For example, with a file list of
 * 'a','b','d' a listBefore='d' will return 'a','b' and a listBefore='c' will
 * also return 'a','b'. Optional.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link FileStatusesResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.listFileStatus = function (listFilePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var listSize = (options && options.listSize !== undefined) ? options.listSize : undefined;
  var listAfter = (options && options.listAfter !== undefined) ? options.listAfter : undefined;
  var listBefore = (options && options.listBefore !== undefined) ? options.listBefore : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'MSLISTSTATUS';
  // Validate
  try {
    if (listFilePath === null || listFilePath === undefined || typeof listFilePath.valueOf() !== 'string') {
      throw new Error('listFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (listSize !== null && listSize !== undefined && typeof listSize !== 'number') {
      throw new Error('listSize must be of type number.');
    }
    if (listAfter !== null && listAfter !== undefined && typeof listAfter.valueOf() !== 'string') {
      throw new Error('listAfter must be of type string.');
    }
    if (listBefore !== null && listBefore !== undefined && typeof listBefore.valueOf() !== 'string') {
      throw new Error('listBefore must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{listFilePath}';
  requestUrl = requestUrl.replace('{listFilePath}', encodeURIComponent(listFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (listSize !== null && listSize !== undefined) {
    queryParameters.push('listSize=' + encodeURIComponent(listSize.toString()));
  }
  if (listAfter !== null && listAfter !== undefined) {
    queryParameters.push('listAfter=' + encodeURIComponent(listAfter));
  }
  if (listBefore !== null && listBefore !== undefined) {
    queryParameters.push('listBefore=' + encodeURIComponent(listBefore));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['FileStatusesResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Gets the file content summary object specified by the file path.
 *
 * @param {string} getContentSummaryFilePath The path to the file to retrieve
 * the summary for.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link ContentSummaryResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.getContentSummary = function (getContentSummaryFilePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'GETCONTENTSUMMARY';
  // Validate
  try {
    if (getContentSummaryFilePath === null || getContentSummaryFilePath === undefined || typeof getContentSummaryFilePath.valueOf() !== 'string') {
      throw new Error('getContentSummaryFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/va/{getContentSummaryFilePath}';
  requestUrl = requestUrl.replace('{getContentSummaryFilePath}', encodeURIComponent(getContentSummaryFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['ContentSummaryResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Get the file status object specified by the file path.
 *
 * @param {string} getFilePath The path to the file to retrieve status for.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link FileStatusResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.getFileStatus = function (getFilePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'GETFILESTATUS';
  // Validate
  try {
    if (getFilePath === null || getFilePath === undefined || typeof getFilePath.valueOf() !== 'string') {
      throw new Error('getFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{getFilePath}';
  requestUrl = requestUrl.replace('{getFilePath}', encodeURIComponent(getFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['FileStatusResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Directly appends to a file with the specified content, without requiring a
 * redirect. This API is NOT webhdfs compliant. It should be used only by
 * tools that do not rely on webhdfs interoperability.
 *
 * @param {string} directFilePath The path to the file to append to.
 * 
 * @param {string} accountname The name of the Data Lake Store account to
 * append to the file in
 * 
 * @param {object} streamContents The file contents to include when appending
 * to the file.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {number} [options.buffersize] The optional buffer size to use when
 * appending data
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {boolean} [options.append] This is the REQUIRED value for this
 * parameter and method combination. Changing the value will result in
 * unexpected behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.append = function (directFilePath, accountname, streamContents, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var buffersize = (options && options.buffersize !== undefined) ? options.buffersize : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'APPEND';
  var append = (options && options.append !== undefined) ? options.append : true;
  // Validate
  try {
    if (directFilePath === null || directFilePath === undefined || typeof directFilePath.valueOf() !== 'string') {
      throw new Error('directFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (streamContents === null || streamContents === undefined) {
      throw new Error('streamContents cannot be null or undefined and it must be of type object.');
    }
    if (buffersize !== null && buffersize !== undefined && typeof buffersize !== 'number') {
      throw new Error('buffersize must be of type number.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (append !== null && append !== undefined && typeof append !== 'boolean') {
      throw new Error('append must be of type boolean.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{directFilePath}';
  requestUrl = requestUrl.replace('{directFilePath}', encodeURIComponent(directFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (buffersize !== null && buffersize !== undefined) {
    queryParameters.push('buffersize=' + encodeURIComponent(buffersize.toString()));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  if (append !== null && append !== undefined) {
    queryParameters.push('append=' + encodeURIComponent(append.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'POST';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/octet-stream';
  // Serialize Request  
  var requestContent = streamContents;
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Directly creates a file with the specified content, without requiring a
 * redirect. This API is NOT webhdfs compliant. It should be used only by
 * tools that do not rely on webhdfs interoperability.
 *
 * @param {string} directFilePath The path to the file to create.
 * 
 * @param {string} accountname The name of the Data Lake Store account to
 * create the file in
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {object} [options.streamContents] The file contents to include when
 * creating the file. This parameter is optional, resulting in an empty file
 * if not specified.
 * 
 * @param {number} [options.buffersize] The size of the buffer used in
 * transferring data.
 * 
 * @param {boolean} [options.overwrite] The indication of if the file should
 * be overwritten.
 * 
 * @param {number} [options.blocksize] The block size of a file, in bytes.
 * 
 * @param {number} [options.replication] The number of replications of a file.
 * 
 * @param {string} [options.permission] The permissions of a file or directory.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {boolean} [options.write] This is the REQUIRED value for this
 * parameter and method combination. Changing the value will result in
 * unexpected behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.create = function (directFilePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var streamContents = (options && options.streamContents !== undefined) ? options.streamContents : undefined;
  var buffersize = (options && options.buffersize !== undefined) ? options.buffersize : undefined;
  var overwrite = (options && options.overwrite !== undefined) ? options.overwrite : undefined;
  var blocksize = (options && options.blocksize !== undefined) ? options.blocksize : undefined;
  var replication = (options && options.replication !== undefined) ? options.replication : undefined;
  var permission = (options && options.permission !== undefined) ? options.permission : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'CREATE';
  var write = (options && options.write !== undefined) ? options.write : true;
  // Validate
  try {
    if (directFilePath === null || directFilePath === undefined || typeof directFilePath.valueOf() !== 'string') {
      throw new Error('directFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (streamContents !== null && streamContents !== undefined && typeof streamContents.valueOf() !== 'object') {
      throw new Error('streamContents must be of type object.');
    }
    if (buffersize !== null && buffersize !== undefined && typeof buffersize !== 'number') {
      throw new Error('buffersize must be of type number.');
    }
    if (overwrite !== null && overwrite !== undefined && typeof overwrite !== 'boolean') {
      throw new Error('overwrite must be of type boolean.');
    }
    if (blocksize !== null && blocksize !== undefined && typeof blocksize !== 'number') {
      throw new Error('blocksize must be of type number.');
    }
    if (replication !== null && replication !== undefined && typeof replication !== 'number') {
      throw new Error('replication must be of type number.');
    }
    if (permission !== null && permission !== undefined && typeof permission.valueOf() !== 'string') {
      throw new Error('permission must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (write !== null && write !== undefined && typeof write !== 'boolean') {
      throw new Error('write must be of type boolean.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{directFilePath}';
  requestUrl = requestUrl.replace('{directFilePath}', encodeURIComponent(directFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (buffersize !== null && buffersize !== undefined) {
    queryParameters.push('buffersize=' + encodeURIComponent(buffersize.toString()));
  }
  if (overwrite !== null && overwrite !== undefined) {
    queryParameters.push('overwrite=' + encodeURIComponent(overwrite.toString()));
  }
  if (blocksize !== null && blocksize !== undefined) {
    queryParameters.push('blocksize=' + encodeURIComponent(blocksize.toString()));
  }
  if (replication !== null && replication !== undefined) {
    queryParameters.push('replication=' + encodeURIComponent(replication.toString()));
  }
  if (permission !== null && permission !== undefined) {
    queryParameters.push('permission=' + encodeURIComponent(permission));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  if (write !== null && write !== undefined) {
    queryParameters.push('write=' + encodeURIComponent(write.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/octet-stream';
  // Serialize Request  
  var requestContent = streamContents;
  httpRequest.body = requestContent;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 201) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Directly opens and reads from the specified file, without requiring a
 * redirect. This API is NOT webhdfs compliant. It should be used only by
 * tools that do not rely on webhdfs interoperability.
 *
 * @param {string} directFilePath The path to the file to open.
 * 
 * @param {string} accountname The name of the data lake account that the file
 * lives in.
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {number} [options.length]
 * 
 * @param {number} [options.offset]
 * 
 * @param {number} [options.buffersize]
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {boolean} [options.read] This is the REQUIRED value for this
 * parameter and method combination. Changing the value will result in
 * unexpected behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.open = function (directFilePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var length = (options && options.length !== undefined) ? options.length : undefined;
  var offset = (options && options.offset !== undefined) ? options.offset : undefined;
  var buffersize = (options && options.buffersize !== undefined) ? options.buffersize : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'OPEN';
  var read = (options && options.read !== undefined) ? options.read : true;
  // Validate
  try {
    if (directFilePath === null || directFilePath === undefined || typeof directFilePath.valueOf() !== 'string') {
      throw new Error('directFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (length !== null && length !== undefined && typeof length !== 'number') {
      throw new Error('length must be of type number.');
    }
    if (offset !== null && offset !== undefined && typeof offset !== 'number') {
      throw new Error('offset must be of type number.');
    }
    if (buffersize !== null && buffersize !== undefined && typeof buffersize !== 'number') {
      throw new Error('buffersize must be of type number.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (read !== null && read !== undefined && typeof read !== 'boolean') {
      throw new Error('read must be of type boolean.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{directFilePath}';
  requestUrl = requestUrl.replace('{directFilePath}', encodeURIComponent(directFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (length !== null && length !== undefined) {
    queryParameters.push('length=' + encodeURIComponent(length.toString()));
  }
  if (offset !== null && offset !== undefined) {
    queryParameters.push('offset=' + encodeURIComponent(offset.toString()));
  }
  if (buffersize !== null && buffersize !== undefined) {
    queryParameters.push('buffersize=' + encodeURIComponent(buffersize.toString()));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  if (read !== null && read !== undefined) {
    queryParameters.push('read=' + encodeURIComponent(read.toString()));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  httpRequest.streamedResponse = true;
  return client.pipeline(httpRequest, function (err, response) {
    if (err) {
      return callback(err);
    }

    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(util.format('Unexpected status code: %s', statusCode));
      error.statusCode = response.statusCode;
      error.request = httpRequest;
      error.response = response;
      return callback(error);
    }

    // Create Result
    var result = response;
    return callback(null, result, httpRequest, response);
  });
};

/**
 * Sets ACL entries on a file or folder.
 *
 * @param {string} setAclFilePath The path to the directory or file to set
 * ACLs on.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {string} aclspec The ACL spec included in ACL creation operations in
 * the format '[default:]user|group|other::r|-w|-x|-'
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.setAcl = function (setAclFilePath, accountname, aclspec, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'SETACL';
  // Validate
  try {
    if (setAclFilePath === null || setAclFilePath === undefined || typeof setAclFilePath.valueOf() !== 'string') {
      throw new Error('setAclFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (aclspec === null || aclspec === undefined || typeof aclspec.valueOf() !== 'string') {
      throw new Error('aclspec cannot be null or undefined and it must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{setAclFilePath}';
  requestUrl = requestUrl.replace('{setAclFilePath}', encodeURIComponent(setAclFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  queryParameters.push('aclspec=' + encodeURIComponent(aclspec));
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Modifies existing ACL entries on a file or folder.
 *
 * @param {string} modifyAclFilePath The path to the directory or file to
 * modify ACLs on.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {string} aclspec The ACL spec included in ACL modification
 * operations in the format '[default:]user|group|other::r|-w|-x|-'
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.modifyAclEntries = function (modifyAclFilePath, accountname, aclspec, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'MODIFYACLENTRIES';
  // Validate
  try {
    if (modifyAclFilePath === null || modifyAclFilePath === undefined || typeof modifyAclFilePath.valueOf() !== 'string') {
      throw new Error('modifyAclFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (aclspec === null || aclspec === undefined || typeof aclspec.valueOf() !== 'string') {
      throw new Error('aclspec cannot be null or undefined and it must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{modifyAclFilePath}';
  requestUrl = requestUrl.replace('{modifyAclFilePath}', encodeURIComponent(modifyAclFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  queryParameters.push('aclspec=' + encodeURIComponent(aclspec));
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Removes existing ACL entries on a file or folder.
 *
 * @param {string} removeAclFilePath The path to the directory or file to
 * remove ACLs on.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {string} aclspec The ACL spec included in ACL removal operations in
 * the format '[default:]user|group|other'
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.removeAclEntries = function (removeAclFilePath, accountname, aclspec, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'REMOVEACLENTRIES';
  // Validate
  try {
    if (removeAclFilePath === null || removeAclFilePath === undefined || typeof removeAclFilePath.valueOf() !== 'string') {
      throw new Error('removeAclFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (aclspec === null || aclspec === undefined || typeof aclspec.valueOf() !== 'string') {
      throw new Error('aclspec cannot be null or undefined and it must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{removeAclFilePath}';
  requestUrl = requestUrl.replace('{removeAclFilePath}', encodeURIComponent(removeAclFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  queryParameters.push('aclspec=' + encodeURIComponent(aclspec));
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Removes default ACL entries on a file or folder.
 *
 * @param {string} removeDefaultAclFilePath The path to the directory or file
 * to remove ACL on.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.removeDefaultAcl = function (removeDefaultAclFilePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'REMOVEDEFAULTACL';
  // Validate
  try {
    if (removeDefaultAclFilePath === null || removeDefaultAclFilePath === undefined || typeof removeDefaultAclFilePath.valueOf() !== 'string') {
      throw new Error('removeDefaultAclFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{removeDefaultAclFilePath}';
  requestUrl = requestUrl.replace('{removeDefaultAclFilePath}', encodeURIComponent(removeDefaultAclFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Removes the existing ACL on a file or folder.
 *
 * @param {string} aclFilePath The path to the directory or file to remove ACL
 * on.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.removeAcl = function (aclFilePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'REMOVEACL';
  // Validate
  try {
    if (aclFilePath === null || aclFilePath === undefined || typeof aclFilePath.valueOf() !== 'string') {
      throw new Error('aclFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{aclFilePath}';
  requestUrl = requestUrl.replace('{aclFilePath}', encodeURIComponent(aclFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Gets ACL entries on a file or folder.
 *
 * @param {string} aclFilePath The path to the directory or file to get ACLs
 * on.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link AclStatusResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.getAclStatus = function (aclFilePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'GETACLSTATUS';
  // Validate
  try {
    if (aclFilePath === null || aclFilePath === undefined || typeof aclFilePath.valueOf() !== 'string') {
      throw new Error('aclFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{aclFilePath}';
  requestUrl = requestUrl.replace('{aclFilePath}', encodeURIComponent(aclFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['AclStatusResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Deletes the requested file or folder, optionally recursively.
 *
 * @param {string} filePath The path to the file or folder to delete.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {boolean} [options.recursive] The optional switch indicating if the
 * delete should be recursive
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link FileOperationResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.deleteMethod = function (filePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var recursive = (options && options.recursive !== undefined) ? options.recursive : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'DELETE';
  // Validate
  try {
    if (filePath === null || filePath === undefined || typeof filePath.valueOf() !== 'string') {
      throw new Error('filePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (recursive !== null && recursive !== undefined && typeof recursive !== 'boolean') {
      throw new Error('recursive must be of type boolean.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{filePath}';
  requestUrl = requestUrl.replace('{filePath}', encodeURIComponent(filePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (recursive !== null && recursive !== undefined) {
    queryParameters.push('recursive=' + encodeURIComponent(recursive.toString()));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'DELETE';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['FileOperationResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Creates a symbolic link.
 *
 * @param {string} symLinkFilePath The path to the directory or file to create
 * a symlink of.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {string} destination The path to create the symlink at
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {boolean} [options.createParent] If the parent directories do not
 * exist, indicates if they should be created.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.createSymLink = function (symLinkFilePath, accountname, destination, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var createParent = (options && options.createParent !== undefined) ? options.createParent : false;
  var op = (options && options.op !== undefined) ? options.op : 'CREATESYMLINK';
  // Validate
  try {
    if (symLinkFilePath === null || symLinkFilePath === undefined || typeof symLinkFilePath.valueOf() !== 'string') {
      throw new Error('symLinkFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (destination === null || destination === undefined || typeof destination.valueOf() !== 'string') {
      throw new Error('destination cannot be null or undefined and it must be of type string.');
    }
    if (createParent !== null && createParent !== undefined && typeof createParent !== 'boolean') {
      throw new Error('createParent must be of type boolean.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{symLinkFilePath}';
  requestUrl = requestUrl.replace('{symLinkFilePath}', encodeURIComponent(symLinkFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  queryParameters.push('destination=' + encodeURIComponent(destination));
  if (createParent !== null && createParent !== undefined) {
    queryParameters.push('createParent=' + encodeURIComponent(createParent.toString()));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Rename a directory or file.
 *
 * @param {string} renameFilePath The path to the directory to move/rename.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {string} destination The path to move/rename the file or folder to
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link FileOperationResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.rename = function (renameFilePath, accountname, destination, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'RENAME';
  // Validate
  try {
    if (renameFilePath === null || renameFilePath === undefined || typeof renameFilePath.valueOf() !== 'string') {
      throw new Error('renameFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (destination === null || destination === undefined || typeof destination.valueOf() !== 'string') {
      throw new Error('destination cannot be null or undefined and it must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{renameFilePath}';
  requestUrl = requestUrl.replace('{renameFilePath}', encodeURIComponent(renameFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  queryParameters.push('destination=' + encodeURIComponent(destination));
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['FileOperationResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Sets the owner of a file or folder.
 *
 * @param {string} setOwnerFilePath The path to the directory or file to set
 * the owner on.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.owner] The username who is the owner of a
 * file/directory, if empty remains unchanged.
 * 
 * @param {string} [options.group] The group who is the group owner of a
 * file/directory, if empty remains unchanged.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.setOwner = function (setOwnerFilePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var owner = (options && options.owner !== undefined) ? options.owner : undefined;
  var group = (options && options.group !== undefined) ? options.group : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'SETOWNER';
  // Validate
  try {
    if (setOwnerFilePath === null || setOwnerFilePath === undefined || typeof setOwnerFilePath.valueOf() !== 'string') {
      throw new Error('setOwnerFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (owner !== null && owner !== undefined && typeof owner.valueOf() !== 'string') {
      throw new Error('owner must be of type string.');
    }
    if (group !== null && group !== undefined && typeof group.valueOf() !== 'string') {
      throw new Error('group must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{setOwnerFilePath}';
  requestUrl = requestUrl.replace('{setOwnerFilePath}', encodeURIComponent(setOwnerFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (owner !== null && owner !== undefined) {
    queryParameters.push('owner=' + encodeURIComponent(owner));
  }
  if (group !== null && group !== undefined) {
    queryParameters.push('group=' + encodeURIComponent(group));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Sets the permission of the file or folder.
 *
 * @param {string} setPermissionFilePath The path to the directory or file to
 * set permissions on.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.permission] A string octal representation of the
 * permission (i.e 'rwx'), if empty remains unchanged.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.setPermission = function (setPermissionFilePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var permission = (options && options.permission !== undefined) ? options.permission : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'SETPERMISSION';
  // Validate
  try {
    if (setPermissionFilePath === null || setPermissionFilePath === undefined || typeof setPermissionFilePath.valueOf() !== 'string') {
      throw new Error('setPermissionFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (permission !== null && permission !== undefined && typeof permission.valueOf() !== 'string') {
      throw new Error('permission must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{setPermissionFilePath}';
  requestUrl = requestUrl.replace('{setPermissionFilePath}', encodeURIComponent(setPermissionFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (permission !== null && permission !== undefined) {
    queryParameters.push('permission=' + encodeURIComponent(permission));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Sets the value of the replication factor.
 *
 * @param {string} setReplicationFilePath The path to the directory or file to
 * create a replication of.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {number} [options.replication] The number of replications of a file.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link FileOperationResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.setReplication = function (setReplicationFilePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var replication = (options && options.replication !== undefined) ? options.replication : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'SETREPLICATION';
  // Validate
  try {
    if (setReplicationFilePath === null || setReplicationFilePath === undefined || typeof setReplicationFilePath.valueOf() !== 'string') {
      throw new Error('setReplicationFilePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (replication !== null && replication !== undefined && typeof replication !== 'number') {
      throw new Error('replication must be of type number.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{setReplicationFilePath}';
  requestUrl = requestUrl.replace('{setReplicationFilePath}', encodeURIComponent(setReplicationFilePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (replication !== null && replication !== undefined) {
    queryParameters.push('replication=' + encodeURIComponent(replication.toString()));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['FileOperationResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Sets the access or modification time on a file or folder.
 *
 * @param {string} sourcePath The path to the directory or file to set
 * permissions on.
 * 
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {number} [options.modificationtime] The modification time of a
 * file/directory. If -1 remains unchanged
 * 
 * @param {number} [options.accesstime] The access time of a file/directory.
 * If -1 remains unchanged
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {null} [result]   - The deserialized result object.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.setTimes = function (sourcePath, accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var modificationtime = (options && options.modificationtime !== undefined) ? options.modificationtime : undefined;
  var accesstime = (options && options.accesstime !== undefined) ? options.accesstime : undefined;
  var op = (options && options.op !== undefined) ? options.op : 'SETTIMES';
  // Validate
  try {
    if (sourcePath === null || sourcePath === undefined || typeof sourcePath.valueOf() !== 'string') {
      throw new Error('sourcePath cannot be null or undefined and it must be of type string.');
    }
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (modificationtime !== null && modificationtime !== undefined && typeof modificationtime !== 'number') {
      throw new Error('modificationtime must be of type number.');
    }
    if (accesstime !== null && accesstime !== undefined && typeof accesstime !== 'number') {
      throw new Error('accesstime must be of type number.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/{sourcePath}';
  requestUrl = requestUrl.replace('{sourcePath}', encodeURIComponent(sourcePath));
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (modificationtime !== null && modificationtime !== undefined) {
    queryParameters.push('modificationtime=' + encodeURIComponent(modificationtime.toString()));
  }
  if (accesstime !== null && accesstime !== undefined) {
    queryParameters.push('accesstime=' + encodeURIComponent(accesstime.toString()));
  }
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'PUT';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;

    return callback(null, result, httpRequest, response);
  });
};

/**
 * Get the home directory for the specified account.
 *
 * @param {string} accountname The name of the account to use
 * 
 * @param {object} [options] Optional Parameters.
 * 
 * @param {string} [options.op] This is the REQUIRED value for this parameter
 * and method combination. Changing the value will result in unexpected
 * behavior, please do not do so.
 * 
 * @param {object} [options.customHeaders] Headers that will be added to the
 * request
 * 
 * @param {function} callback
 *
 * @returns {function} callback(err, result, request, response)
 *
 *                      {Error}  err        - The Error object if an error occurred, null otherwise.
 *
 *                      {object} [result]   - The deserialized result object.
 *                      See {@link HomeDirectoryResult} for more information.
 *
 *                      {object} [request]  - The HTTP Request object if an error did not occur.
 *
 *                      {stream} [response] - The HTTP Response stream if an error did not occur.
 */
FileSystem.prototype.getHomeDirectory = function (accountname, options, callback) {
  var client = this.client;
  if(!callback && typeof options === 'function') {
    callback = options;
    options = null;
  }
  if (!callback) {
    throw new Error('callback cannot be null.');
  }
  var op = (options && options.op !== undefined) ? options.op : 'GETHOMEDIRECTORY';
  // Validate
  try {
    if (accountname === null || accountname === undefined || typeof accountname.valueOf() !== 'string') {
      throw new Error('accountname cannot be null or undefined and it must be of type string.');
    }
    if (op !== null && op !== undefined && typeof op.valueOf() !== 'string') {
      throw new Error('op must be of type string.');
    }
    if (this.client.apiVersion === null || this.client.apiVersion === undefined || typeof this.client.apiVersion.valueOf() !== 'string') {
      throw new Error('this.client.apiVersion cannot be null or undefined and it must be of type string.');
    }
    if (this.client.subscriptionId === null || this.client.subscriptionId === undefined || typeof this.client.subscriptionId.valueOf() !== 'string') {
      throw new Error('this.client.subscriptionId cannot be null or undefined and it must be of type string.');
    }
    if (this.client.datalakeserviceuri === null || this.client.datalakeserviceuri === undefined || typeof this.client.datalakeserviceuri.valueOf() !== 'string') {
      throw new Error('this.client.datalakeserviceuri cannot be null or undefined and it must be of type string.');
    }
    if (this.client.acceptLanguage !== null && this.client.acceptLanguage !== undefined && typeof this.client.acceptLanguage.valueOf() !== 'string') {
      throw new Error('this.client.acceptLanguage must be of type string.');
    }
  } catch (error) {
    return callback(error);
  }

  // Construct URL
  var requestUrl = this.client.baseUri +
                   '//webhdfs/v1/';
  requestUrl = requestUrl.replace('accountname', encodeURIComponent(accountname));
  requestUrl = requestUrl.replace('datalakeserviceuri', encodeURIComponent(this.client.datalakeserviceuri));
  var queryParameters = [];
  if (op !== null && op !== undefined) {
    queryParameters.push('op=' + encodeURIComponent(op));
  }
  queryParameters.push('api-version=' + encodeURIComponent(this.client.apiVersion));
  if (queryParameters.length > 0) {
    requestUrl += '?' + queryParameters.join('&');
  }
  // trim all duplicate forward slashes in the url
  var regex = /([^:]\/)\/+/gi;
  requestUrl = requestUrl.replace(regex, '$1');

  // Create HTTP transport objects
  var httpRequest = new WebResource();
  httpRequest.method = 'GET';
  httpRequest.headers = {};
  httpRequest.url = requestUrl;
  // Set Headers
  if (this.client.generateClientRequestId) {
      httpRequest.headers['x-ms-client-request-id'] = msRestAzure.generateUuid();
  }
  if (this.client.subscriptionId !== undefined && this.client.subscriptionId !== null) {
    httpRequest.headers['subscriptionId'] = this.client.subscriptionId;
  }
  if (this.client.acceptLanguage !== undefined && this.client.acceptLanguage !== null) {
    httpRequest.headers['accept-language'] = this.client.acceptLanguage;
  }
  if(options) {
    for(var headerName in options['customHeaders']) {
      if (options['customHeaders'].hasOwnProperty(headerName)) {
        httpRequest.headers[headerName] = options['customHeaders'][headerName];
      }
    }
  }
  httpRequest.headers['Content-Type'] = 'application/json; charset=utf-8';
  httpRequest.body = null;
  httpRequest.headers['Content-Length'] = 0;
  // Send Request
  return client.pipeline(httpRequest, function (err, response, responseBody) {
    if (err) {
      return callback(err);
    }
    var statusCode = response.statusCode;
    if (statusCode !== 200) {
      var error = new Error(responseBody);
      error.statusCode = response.statusCode;
      error.request = msRest.stripRequest(httpRequest);
      error.response = msRest.stripResponse(response);
      if (responseBody === '') responseBody = null;
      var parsedErrorResponse;
      try {
        parsedErrorResponse = JSON.parse(responseBody);
        if (parsedErrorResponse) {
          if (parsedErrorResponse.error) parsedErrorResponse = parsedErrorResponse.error;
          if (parsedErrorResponse.code) error.code = parsedErrorResponse.code;
          if (parsedErrorResponse.message) error.message = parsedErrorResponse.message;
        }
        if (parsedErrorResponse !== null && parsedErrorResponse !== undefined) {
          var resultMapper = new client.models['CloudError']().mapper();
          error.body = client.deserialize(resultMapper, parsedErrorResponse, 'error.body');
        }
      } catch (defaultError) {
        error.message = util.format('Error "%s" occurred in deserializing the responseBody ' + 
                         '- "%s" for the default response.', defaultError.message, responseBody);
        return callback(error);
      }
      return callback(error);
    }
    // Create Result
    var result = null;
    if (responseBody === '') responseBody = null;
    // Deserialize Response
    if (statusCode === 200) {
      var parsedResponse = null;
      try {
        parsedResponse = JSON.parse(responseBody);
        result = JSON.parse(responseBody);
        if (parsedResponse !== null && parsedResponse !== undefined) {
          var resultMapper = new client.models['HomeDirectoryResult']().mapper();
          result = client.deserialize(resultMapper, parsedResponse, 'result');
        }
      } catch (error) {
        var deserializationError = new Error(util.format('Error "%s" occurred in deserializing the responseBody - "%s"', error, responseBody));
        deserializationError.request = msRest.stripRequest(httpRequest);
        deserializationError.response = msRest.stripResponse(response);
        return callback(deserializationError);
      }
    }

    return callback(null, result, httpRequest, response);
  });
};


module.exports = FileSystem;

